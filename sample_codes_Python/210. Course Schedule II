class Solution:
        
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        adj_list = defaultdict(list)
        
        for course, pre_course in prerequisites:
            adj_list[pre_course].append(course)
        
        solution = []
        
        course_status = [0] * numCourses #[0 for k in range(numCourses)]

        def helper(course: int) -> bool:

            adjacent = adj_list[course]

            course_status[course] = 1

            for adjacent_course in adjacent:
                if course_status[adjacent_course] is 1:
                    return False
                if course_status[adjacent_course] is 2:
                    continue
                flag = helper(adjacent_course)
                if not flag:
                    return False
                
            course_status[course] = 2
            solution.append(course)
            return True
    
        for i in range(numCourses):
            if course_status[i] is 0:
                flag = helper(i)
                if not flag:
                    return []

        solution.reverse()
        #solution = solution[::-1]
        
        return solution

'''
from collections import defaultdict
class Solution:

    WHITE = 1
    GRAY = 2
    BLACK = 3

    def findOrder(self, numCourses, prerequisites):
        """
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: List[int]
        """

        # Create the adjacency list representation of the graph
        adj_list = defaultdict(list)

        # A pair [a, b] in the input represents edge from b --> a
        for dest, src in prerequisites:
            adj_list[src].append(dest)

        topological_sorted_order = []
        is_possible = True

        # By default all vertces are WHITE
        color = {k: Solution.WHITE for k in range(numCourses)}
        def dfs(node):
            nonlocal is_possible

            # Don't recurse further if we found a cycle already
            if not is_possible:
                return

            # Start the recursion
            color[node] = Solution.GRAY

            # Traverse on neighboring vertices
            if node in adj_list:
                for neighbor in adj_list[node]:
                    if color[neighbor] == Solution.WHITE:
                        dfs(neighbor)
                    elif color[neighbor] == Solution.GRAY:
                         # An edge to a GRAY vertex represents a cycle
                        is_possible = False

            # Recursion ends. We mark it as black
            color[node] = Solution.BLACK
            topological_sorted_order.append(node)

        for vertex in range(numCourses):
            # If the node is unprocessed, then call dfs on it.
            if color[vertex] == Solution.WHITE:
                dfs(vertex)

        return topological_sorted_order[::-1] if is_possible else []
'''
        
