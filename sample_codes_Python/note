1472. Design Browser History

*Does a slicing operation give me a deep or shallow copy? (important)
https://stackoverflow.com/questions/19068707/does-a-slicing-operation-give-me-a-deep-or-shallow-copy
Example:
a = [{"a": "b"}, 2]
b = a[:1]
b[0]["a"] = "f"
print(a, b)

*slice (similar to C++ resize)
Example:
    def visit(self, url: str) -> None:
        self.webpage = self.webpage[:self.cur + 1]
        self.webpage.append(url)
        self.cur = len(self.webpage) - 1

*return None value:
Example:
    def visit(self, url: str) -> None:
        self.webpage = self.webpage[:self.cur + 1]
        self.webpage.append(url)
        self.cur = len(self.webpage) - 1

**args and **kwargs
Example:
def viking_chorus(myfunc):
    def inner_func(*args, **kwargs):
        for i in range(8):
            myfunc(*args, **kwargs)
    return inner_func
    
*reverse a list:
solution.reverse()
or
solution = solution[::-1]

*Initialize a list with zeros:
Example:
course_status = [0] * numCourses #[0 for k in range(numCourses)]

*Negate a bool:
if not flag:
 dosomething...

*__init__.py
https://stackoverflow.com/questions/448271/what-is-init-py-for

*class
class QCLoad(object):
 def __init__(self):
  self.label = "something"

*What is the difference between dict and collections.defaultdict?
https://stackoverflow.com/questions/6589814/what-is-the-difference-between-dict-and-collections-defaultdict
The difference is that a defaultdict will "default" a value if that key has not been set yet. If you didn't use a defaultdict you'd have to check to see if that key exists, and if it doesn't, set it to what you want.

The lambda is defining a factory for the default value. That function gets called whenever it needs a default value. You could hypothetically have a more complicated default function.

*itermediate tutorial:
https://www.youtube.com/watch?v=HGOBQPFzWKo&t=201s

*mylist = [a,b,c]

*if something:
 else:
 
*len(mylist)

*mylist.append(something)

*mylist.insert(1, something)

*item = mylist.pop() #returns and remove

*mylist.remove(something)

*mylist.clear()

*mylist.reverse() or mylist[::-1]

*mylist.sort()

*new_list = sorted(mylist)

*mylist = [0] * 5

*mylist2 = mylist + mylist2 #this is concatenation of two lists

*a = mylist[1:5] #the last index is excluded

*a = mylist[:5] or a = mylist[1:] or a = mylist[::1]

*list_org = [...]
 list_cpy = list_org #both refer to the same memory
 list_cpy = list_org.copy() #not refer to the same memory
 list_cpy = list(list_org) #creat a new list
 list_cpy = list_or[:] #not refer to the same memory
 
*list comprehension
 mylist = [1, 2, ...6]
 b = [i*i for i in mylist]
 
*tuple cannot be changed after creation

*the parentesis is optional for tuple

*mytuple=("Max") #not recognized as a tuple, put comma after it
print(type(mytuple)) #str

*mytuple[0] = "New" #error

*my_tuple.count('p')

*my_tuple.index('p')

*unpack:
name, age, city = my_tuple
i1, *i2, i3 = mytuple #i1 is the first, and i3 is the last, and i2 is converted to a list!

*sys:
import sys
sys.getsizeof(my_list)

*timeit
timeit.timeit(stmt="[0, ...,5]", number = 100000)

*mydict = {"name": "Max, "age": 28, ...}
 mydict = dict(name = "Mary, age = 27, ...)
 mydict["email"] = "max..."
 del mydict["name"] #delete the key
 mydict.pop("age")
 mydict.popitem() #removes the last one after 3.7.1
 if "name" in mydict:
  print(...)
 for key in mydict:
   print(key)
 for key in mydict.keys():
   print(key)
 for value in mydict.values():
   print(value)
 for key, value in mydict.items():
   print(key, value)
 mydict_cpy = mydict #same as original one
 mydict_cpy = mydict.copy()
 mydict_cpy = dict(mydict)
 mydict.update(my_dict_2) #mydict is updated by my_dict_2
 
 mytuple = (8, 7)
 mydict = {mytuple : 15} #tuple is OK, list is not OK!
 
*set (unordered, mutable, no duplicates)
myset = {1, 2, 3}
myset = set([1, 2, 3])
myset = set("Hello")
myset = {}
print(type(myset)) #dictionary!
myset.add(1)
myset.remove(4)
myset.discard(3) #no error message if not found
myset.clear()
myset.pop() #return and remove
for i in myset:
    print(i)
u = odds.union(evens) #union!
i = odds.intersection(evens)
diff = setA.difference(setB) #the ones in setA but not in setB
diff = setB.symmetric_difference(setA) #both in setA and setB
setA.update(setB) #union and setA is updated in place!
setA.intersection_update(setB) #intersection and setA is updated in place!
setA.difference_update(setB) #same thing
setA.symmetric_difference_update(setB) #same thing
setA.issubset(setB)
setB.issuperset(setA)
setA.isdisjoint(setB) #no intersection returns true
setB = setA
setB = setA.copy()
setB = set(setA)

*a = frozenset([1, 2, 3, 4]) #cannot change after creation
 a.add(2) #error
 a.remove(1) #error
 
*string #ordered, immutable!, text representation
my_string = "Hello World" or 'Hello World"
my_string = 'I\'m a programmer' or "I'm a programmer" #!!!
my_string = """Hello \ #\ means continue in the next line
World""" #multi-line quote

*try:
 except:

*strings
my_string = "Hello World"
char = my_string[0]
char = my_string[-1]
my_string[0] = 'h' #error! strings are immutable
substring = my_string[1:5] #index 5 is excluded
substring = my_string[:5]
substring = my_string[::-1] #reverse the string!
sentence = greeting + " " + name
for i in greeting:
   print(i)
if 'e' in greeting:
   print('yes')
else:
   print('no')
my_string = my_string.strip() #remove the white space before and after #have to assign it to update as it is immutable
my_string.upper()
my_string.lower()
my_string.startswith('Hello') #check whether starts with 'Hello'
my_string.endswith('Hello')
my_string.find('o')
my_string.find('lo') #-1 returned if not found
my_string.count('o')
my_string.replace('World', 'Universe') #return a new string #does nothing is not found
my_list = my_string.split() #convert to a list separated by space, default is " "
my_list = my_string.split(",")
new_string = ' '.join(my_list) #convert a list to a string
my_list = ['a'] * 6
my_string = ''.join(my_list)
#%, .format(), f-strings #three formatting
method 1:
var = "Tom"
my_string = "the variable is %s" % var
var = 3
my_string = "the variable is %d" % var
var = 3.1234567
my_string = "the variable is %f" % var #default 6 digits
my_string = "the variable is %.2f" % var

method 2:
var = 3.1234567
my_string = "the variable is {}".format(var)
var2 = 6
my_string = "the variable is {:.2f} and {}".format(var, var2)

method 3 (f-string since 3.6):
my_string = f"the variable is {var} and {var2}"
my_string = f"the variable is {var*2} and {var2}"

*from timeit import default_timer as timer
start = timer()
end = timer()
print(end - start)

*collections: counter, namedtuple, OrderedDict, defaultdict, deque
*Counter
from collections import Counter
a = 'aaaaabbbccc'
my_counter = Counter(a)
print(my_counter)
Counter({'a': 5, 'b': 4, 'c': 3})
my_counter.keys()
my_counter.values()
my_counter.most_common(1) #the most common
[('a', 5)]
my_counter.most_common(1)[0][0]
a
list(my_counter.elements()) #in list() it is the iterator

*namedtuple
from collections import namedtuple

*How can I do a line break (line continuation) in Python?
https://stackoverflow.com/questions/53162/how-can-i-do-a-line-break-line-continuation-in-python
Only use when necessary!
Example:
if a == True and \
   b == False
   
*Python tutorial:
https://www.w3schools.com/python/python_inheritance.asp
https://www.python-course.eu/python3_inheritance.php

*Decorator:
https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators
https://wiki.python.org/moin/PythonDecorators
https://www.python.org/dev/peps/pep-0318/







 















