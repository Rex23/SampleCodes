class Solution {
    
    int n;
    HashMap <String, List <String> > hash_string_des = new HashMap<>();
    HashMap <String, boolean[] > hash_string_flags = new HashMap<>();
    
    List <String> result = new ArrayList<>();
    
    boolean helper(String start, List <String> solution)
    {
        if (solution.size() == n + 1)
        {
            result = solution;
            return true;
        }
        
        if (!hash_string_des.containsKey(start)) return false;
        
        var des = hash_string_des.get(start);
        var flags = hash_string_flags.get(start);
        
        for (int i = 0; i < des.size(); ++i)
        {
            if (flags[i] == true) continue;
            
            var next = des.get(i);
            flags[i] = true;
            
            solution.add(next);
            
            boolean val = helper(next, solution);
            
            if (val) return true;
            
            flags[i] = false;
            solution.remove(solution.size() - 1);
        }
        
        return false;
    }    
    
    public List<String> findItinerary(List<List<String>> tickets) {
        
        n = tickets.size();
        
        for (var i = 0; i < tickets.size(); ++i)
        {
            if (hash_string_des.containsKey(tickets.get(i).get(0)))
            {
                List <String> values = hash_string_des.get(tickets.get(i).get(0));
                
                //System.out.println(tickets.get(i).get(1));
                
                values.add(tickets.get(i).get(1));
            }
            else
            {
                List <String> values = new ArrayList<>();
                values.add(tickets.get(i).get(1));
                
                //System.out.println(tickets.get(i).get(1));
                
                hash_string_des.put(tickets.get(i).get(0), values);
            }
            
        }
        
        for (var item : hash_string_des.entrySet())
        {
            Collections.sort(item.getValue());
            boolean[] values = new boolean[item.getValue().size()];
            hash_string_flags.put(item.getKey(), values);
            
            //System.out.println(item.getKey() + " " + values.length);
        }
        
        List <String> solution = new ArrayList<>();
        solution.add("JFK");
        
        helper("JFK", solution);
                
        return result;        
    }
}

/*
class Solution {
        
    int n;
    
    std::unordered_map <string, std::vector <string> > hash_string_des;
    std::unordered_map <string, std::vector <bool> > hash_string_flags;
    
    std::vector <string> result;
    
    bool helper(const string& start, vector <string>& solution)
    {
        if (solution.size() == n + 1)
        {
            result = solution;
            return true;
        }
        
        auto& des = hash_string_des[start];
        auto& flags = hash_string_flags[start];
        
        for (int i = 0; i < des.size(); ++i)
        {
            if (flags[i] == true) continue;
            
            auto& next = des[i];
            flags[i] = true;
            
            solution.push_back(next);
            
            bool val = helper(next, solution);
            
            if (val) return true;
            
            flags[i] = false;
            solution.pop_back();
        }
        
        return false;
    }
    
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        
        //This is a very important and classic problem. Highest priority. The key is to sort the destinations and once found the result, directly return. Definitely re-do! Get familiar with two methods!
        
        n = tickets.size();
        
        for (int i = 0; i < tickets.size(); ++i)
        {
            hash_string_des[tickets[i][0]].push_back(tickets[i][1]);
        }
        
        for (auto& item : hash_string_des)
        {
            sort(item.second.begin(), item.second.end());
            hash_string_flags[item.first].resize(item.second.size());
        }
        
        vector <string> solution{"JFK"};
        helper("JFK", solution);
        
        return result;
    }
};
*/
/*
class Solution {
  // origin -> list of destinations
  HashMap<String, List<String>> flightMap = new HashMap<>();
  HashMap<String, boolean[]> visitBitmap = new HashMap<>();
  int flights = 0;
  List<String> result = null;


  public List<String> findItinerary(List<List<String>> tickets) {
    // Step 1). build the graph first
    for (List<String> ticket : tickets) {
      String origin = ticket.get(0);
      String dest = ticket.get(1);
      if (this.flightMap.containsKey(origin)) {
        List<String> destList = this.flightMap.get(origin);
        destList.add(dest);
      } else {
        List<String> destList = new LinkedList<String>();
        destList.add(dest);
        this.flightMap.put(origin, destList);
      }
    }

    // Step 2). order the destinations and init the visit bitmap
    for (Map.Entry<String, List<String>> entry : this.flightMap.entrySet()) {
      Collections.sort(entry.getValue());
      this.visitBitmap.put(entry.getKey(), new boolean[entry.getValue().size()]);
    }

    this.flights = tickets.size();
    LinkedList<String> route = new LinkedList<String>();
    route.add("JFK");

    // Step 3). backtracking
    this.backtracking("JFK", route);
    return this.result;
  }

  protected boolean backtracking(String origin, LinkedList<String> route) {
    if (route.size() == this.flights + 1) {
      this.result = (List<String>) route.clone();
      return true;
    }

    if (!this.flightMap.containsKey(origin))
      return false;

    int i = 0;
    boolean[] bitmap = this.visitBitmap.get(origin);

    for (String dest : this.flightMap.get(origin)) {
      if (!bitmap[i]) {
        bitmap[i] = true;
        route.add(dest);
        boolean ret = this.backtracking(dest, route);
        route.pollLast();
        bitmap[i] = false;

        if (ret)
          return true;
      }
      ++i;
    }

    return false;
  }
}
*/
