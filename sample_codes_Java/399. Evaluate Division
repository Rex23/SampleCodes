class Solution {
    
    Map <String, List<Pair <String, Double>> > hash_x_y = new HashMap <>();
        
    boolean helper(double num, String input, Set <String> used, String final_denom, double[] final_num)
    {        
        if (!hash_x_y.containsKey(input)) 
        {
            final_num[0] = -1.0;
            return false;
        }
        
        if (input.equals(final_denom))
        {
            final_num[0] = num * 1.0;
            return true;
        }        
        
        var range = hash_x_y.get(input);
        
        for (int i = 0; i < range.size(); ++i)
        {
            double quot = range.get(i).getValue();
            String denom = range.get(i).getKey();
            
            if (!used.contains(denom))
            {
                used.add(denom);
                boolean flag = helper(num * quot, denom, used, final_denom, final_num);
                if (flag) return true;
                used.remove(denom);
            }
        }
        
        final_num[0] = -1.0;
        return false;
    }    
    
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        
        //backtracking can solve it. A very good practise.
        
        for (int i = 0; i < equations.size(); ++i)
        {
            String a = equations.get(i).get(0);
            String b = equations.get(i).get(1);
            
            if (!hash_x_y.containsKey(a))
            {
                List<Pair<String, Double>> a_list = new ArrayList<>();
                a_list.add(new Pair <String, Double>(b, values[i]));
                hash_x_y.put(a, a_list);
                
                if (!hash_x_y.containsKey(b))
                {
                    List<Pair<String, Double>> a_list2 = new ArrayList<>();
                    a_list2.add(new Pair <String, Double>(a, 1.0 / values[i]));
                    hash_x_y.put(b, a_list2);                    
                }
                else
                {
                    hash_x_y.get(b).add(new Pair <String, Double>(a, 1.0 / values[i]));
                }
            }
            else
            {
                hash_x_y.get(a).add(new Pair <String, Double>(b, values[i]));
                
                if (!hash_x_y.containsKey(b))
                {
                    List<Pair<String, Double>> a_list2 = new ArrayList<>();
                    a_list2.add(new Pair <String, Double>(a, 1.0 / values[i]));
                    hash_x_y.put(b, a_list2);                    
                }
                else
                {
                    hash_x_y.get(b).add(new Pair <String, Double>(a, 1.0 / values[i]));
                }
            }
        }
        
        double[] result = new double[queries.size()];
        
        for (int i = 0; i < queries.size(); ++i)
        {
            Set <String> used = new HashSet<>();
            used.add(queries.get(i).get(0));
            double[] final_num = new double[1];
            helper(1.0, queries.get(i).get(0), used, queries.get(i).get(1), final_num);
            result[i] = final_num[0];
        }        
        
        return result;
    }
}

/*
class Solution {
    
    unordered_multimap <string, pair <string, double> > hash_x_y;
    
    bool helper(double num, string& input, unordered_set <string>& used, const string& final_denom, double& num_next)
    {        
        if (hash_x_y.find(input) == hash_x_y.end()) 
        {
            num_next = -1.0;
            return false;
        }
        
        if (input == final_denom)
        {
            num_next = num * 1.0;
            return true;
        }        
        
        auto range = hash_x_y.equal_range(input);
        
        for (auto iter = range.first; iter != range.second; iter++)
        {
            double quot = iter -> second.second;
            string denom = iter -> second.first;
                        
            if (used.find(denom) == used.end())
            {
                used.insert(denom);
                bool flag = helper(num * quot, denom, used, final_denom, num_next);
                if (flag) return true;
                used.erase(denom);
            }
        }
        
        num_next = -1.0;
        return false;
    }
    
public:
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        
        //backtracking can solve it. A very good practise.
        
        for (int i = 0; i < equations.size(); ++i)
        {
            hash_x_y.insert( {equations[i][0], {equations[i][1], values[i]}} );
            hash_x_y.insert( {equations[i][1], {equations[i][0], 1.0 / values[i]}} );
        }
        
        vector <double> result;
        
        for (int i = 0; i < queries.size(); ++i)
        {
            unordered_set <string> used{queries[i][0]};
            double num_next;
            helper(1.0, queries[i][0], used, queries[i][1], num_next);
            result.push_back(num_next);
        }
        
        return result;
    }
};
*/
