********************************************************
heap:
https://www.geeksforgeeks.org/heap-data-structure/
Bottom-up and Top-Down DP:
https://www.geeksforgeeks.org/tabulation-vs-memoization/
********************************************************

Java and Python:
1472. Design Browser History (Java and Python)
1557. Minimum Number of Vertices to Reach All Nodes (Java and Python)
393. UTF-8 Validation (Java and Python)
93. Restore IP Addresses (Java and Python)
71. Simplify Path (Java and Python)
210. Course Schedule II (Java and Python)
133. Clone Graph (Java and Python)
1042. Flower Planting With No Adjacent (Java and Python)
785. Is Graph Bipartite?
74. Search a 2D Matrix
55. Jump Game
846. Hand of Straights
777. Swap Adjacent in LR String
652. Find Duplicate Subtrees
444. Sequence Reconstruction
1202. Smallest String With Swaps
901. Online Stock Span
1049. Last Stone Weight II
241. Different Ways to Add Parentheses
113. Path Sum II
779. K-th Symbol in Grammar
959. Regions Cut By Slashes
861. Score After Flipping Matrix
457. Circular Array Loop
1578. Minimum Deletion Cost to Avoid Repeating Letters
222. Count Complete Tree Nodes
1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold
40. Combination Sum II
843. Guess the Word
373. Find K Pairs with Smallest Sums
23. Merge k Sorted Lists
767. Reorganize String
727. Minimum Window Subsequence
841. Keys and Rooms
1135. Connecting Cities With Minimum Cost
1153. String Transforms Into Another String
68. Text Justification
323. Number of Connected Components in an Undirected Graph
1615. Maximal Network Rank
1192. Critical Connections in a Network
1102. Path With Maximum Minimum Value (note the python solutions in the discussion!)
260. Single Number III
137. Single Number II
780. Reaching Points
1368. Minimum Cost to Make at Least One Valid Path in a Grid
735. Asteroid Collision
301. Remove Invalid Parentheses
19. Remove Nth Node From End of List
749. Contain Virus
128. Longest Consecutive Sequence
825. Friends Of Appropriate Ages
536. Construct Binary Tree from String
802. Find Eventual Safe States (Java and Python)
1335. Minimum Difficulty of a Job Schedule (Java and Python)
1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance (Java and Python)
295. Find Median from Data Stream (Java and Python (Good practise of heap))
990. Satisfiability of Equality Equations
743. Network Delay Time (Java and Python)
886. Possible Bipartition
1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree
1641. Count Sorted Vowel Strings
980. Unique Paths III
1273. Delete Tree Nodes
1664. Ways to Make a Fair Array
712. Minimum ASCII Delete Sum for Two Strings
1143. Longest Common Subsequence
1328. Break a Palindrome
1105. Filling Bookcase Shelves
904. Fruit Into Baskets
1402. Reducing Dishes
1055. Shortest Way to Form String
1504. Count Submatrices With All Ones
759. Employee Free Time (The given Jave solution has to be figured out!)
516. Longest Palindromic Subsequence
1372. Longest ZigZag Path in a Binary Tree
1255. Maximum Score Words Formed by Letters
1066. Campus Bikes II
96. Unique Binary Search Trees
1274. Number of Ships in a Rectangle
646. Maximum Length of Pair Chain (Practise Java!)
1463. Cherry Pickup II
669. Trim a Binary Search Tree
431. Encode N-ary Tree to Binary Tree
885. Spiral Matrix III
1405. Longest Happy String
489. Robot Room Cleaner
337. House Robber III
1140. Stone Game II
1028. Recover a Tree From Preorder Traversal
85. Maximal Rectangle
1026. Maximum Difference Between Node and Ancestor
1235. Maximum Profit in Job Scheduling
616. Add Bold Tag in String (Java to do)
407. Trapping Rain Water II (Java to do)
384. Shuffle an Array
277. Find the Celebrity
726. Number of Atoms (Java and Python to do)
428. Serialize and Deserialize N-ary Tree (Java and Python to do)
187. Repeated DNA Sequences
228. Summary Ranges
993. Cousins in Binary Tree
297. Serialize and Deserialize Binary Tree
403. Frog Jump
124. Binary Tree Maximum Path Sum
435. Non-overlapping Intervals
834. Sum of Distances in Tree (Java and Python to do)
1672. Richest Customer Wealth (Python to do)
286. Walls and Gates
471. Encode String with Shortest Length
1326. Minimum Number of Taps to Open to Water a Garden
828. Count Unique Characters of All Substrings of a Given String
1229. Meeting Scheduler
1029. Two City Scheduling
239. Sliding Window Maximum (Java to do!)
1239. Maximum Length of a Concatenated String with Unique Characters
920. Number of Music Playlists
43. Multiply Strings
741. Cherry Pickup
863. All Nodes Distance K in Binary Tree
468. Validate IP Address
1091. Shortest Path in Binary Matrix
140. Word Break II
314. Binary Tree Vertical Order Traversal
1163. Last Substring in Lexicographical Order
102. Binary Tree Level Order Traversal (Java and Python)
150. Evaluate Reverse Polish Notation (Java and Python)
151. Reverse Words in a String
494. Target Sum
542. 01 Matrix
1383. Maximum Performance of a Team
1722. Minimize Hamming Distance After Swap Operations
1723. Find Minimum Time to Finish All Jobs
315. Count of Smaller Numbers After Self
698. Partition to K Equal Sum Subsets
416. Partition Equal Subset Sum
114. Flatten Binary Tree to Linked List
218. The Skyline Problem
622. Design Circular Queue
912. Sort an Array
658. Find K Closest Elements
567. Permutation in String
165. Compare Version Numbers (Java and Python to do)
1220. Count Vowels Permutation
845. Longest Mountain in Array
1155. Number of Dice Rolls With Target Sum
316. Remove Duplicate Letters (Python and Jave to do)
472. Concatenated Words
436. Find Right Interval
1727. Largest Submatrix With Rearrangements
1728. Cat and Mouse II
1027. Longest Arithmetic Subsequence
1685. Sum of Absolute Differences in a Sorted Array
679. 24 Game
130. Surrounded Regions
41. First Missing Positive
386. Lexicographical Numbers
935. Knight Dialer
363. Max Sum of Rectangle No Larger Than K
678. Valid Parenthesis String
173. Binary Search Tree Iterator
1684. Count the Number of Consistent Strings (Python)
545. Boundary of Binary Tree
341. Flatten Nested List Iterator (Python and Jave to do)

*Remembered problems:

1. The rainfall volumes between the mountains

2. randomly shuffle an array of numbers

3. a string problem?

4. rvalue reference

5. hash table

6. virtual table?

7. rvalue reference

7. Chicago trading interview problem

7. HackerRank

7. Two's complement?

7. What is a priority queue? 

7. What is a sliding window algorithm?

7. std::move forward? in C++

7. mergesort algorithm re-do to get familiar

287 + 222 + 201 + 186 + 133 + 101 + 91 + 63 + 63 + 61 + 58 + 54 + 39 + 25 = 1584 (there are overlapping problems!)

************Have to re-do!***************
(R) 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (Highest priority problem! No need to say more. Re-do!!!!!!!!!!! See solutions and see similar problems!)
(R) 240. Search a 2D Matrix II (search space reduction method. Have to re-do!!!!!! High freq and classic!)
(R) 406. Queue Reconstruction by Height (The solution is excellent!!!!!! Did not figure out the solution! Have to re-do!!!!!!!!! Very important!!!!!!!!! sort first by h and then by k)
(R) 348. Design Tic-Tac-Toe (classic high freq and very very important!!!!!! did not figure out the solution. Have to re-do!!!!!!)
(R) 362. Design Hit Counter (Very good design question. Classic!!! Made too many mistakes. Re-do or get familiar with the solution. Key: find an element <= threshhold, first use upper bound, and if the iter = a_vec.begin(), it means that the element cannot be found. This is different from finding an element which >= threshhold.)
(R) 957. Prison Cells After N Days (Definitly re-do!!!!!!!!!!!! Mado so many mistakes and high freq. hash map. The main issue was that when reminder == 0, it needs to obtain the last ele, however, through the equation it got the previous last, which is out of bound!!!)
(R) 134. Gas Station (High frequency!!! I did not figure out the solution at all. Will forget. Have to re-do!!!!!!)
(R) 1197. Minimum Knight Moves (Classic! Highest priority! Have to re-do!!!!!! Very very very important!!!!!!)
(R) 179. Largest Number (Classic and high frequency!!!!!! Very very very important!!!!!! Have to re-do, re-do, re-do!!!!!!)
(R) 621. Task Scheduler (The solution is unique!!! The trick is to find the max count letters' taking space, and the compare with the task size to find the maximum!!! High freq. Did not figure it out. re-do!!!!!!!!!!!!!!!!)
(R) 131. Palindrome Partitioning (Backtracking. Note that the solution usually needs to pop_back()!!! May forget to use backtracking. re-do!!!!!!)
(R) 152. Maximum Product Subarray (High frequency. dynamic programming. Look at recommended similar quesitons. O(n) to solve it!!! very important. Can be reviewed together with problem 53 Maximum Subarray. The key here is that for any element, the maximum can either be current, or min * cur, or max * cur. re-do!!!!!!!!!!!)
(R) 105. Construct Binary Tree from Preorder and Inorder Traversal (This is a classic and important question!!!!!! Note that pre-order, in-order, and post-order corresponds to DFS concept, which is different from BFS. Note that in-order can naturally split the array into left portion and right portion. Have to re-do!!!!!!)
33. Search in Rotated Sorted Array (This is a classic problem!!!!!! Have to re-do!!!!!! And see the solution in the discussions!!!!!!)
402. Remove K Digits (This problem is very hard to me! Have to re-do!!!!!! Very important!!!!!! Several things: 1. reverse the stack. 2. remove the leading zeros 3. remove more from the end if k is not reached. 4. become "0" if the return is empty.)
636. Exclusive Time of Functions (Did not figure out the solution!!! Definitely re-do!!!!!! The key is to substract the adjacent internal one. It is assumed that end and start corresponds to the same func!)
200. Number of Islands (Have to re-do. Did not figure out. DFS, BFS, and Union Find. Get familiar with all the methods and the complexities.)
684. Redundant Connection (A very important union find question. Find the edge which can make a cycle. Maybe see the DFS solution later? Similar to problem 200.)
146. LRU Cache (Very easy to make mistakes. Highest priority. Use list and hash. Re-do!!!!!!)
829. Consecutive Numbers Sum (It is math! Remember and re-do!!!)
23. Merge k Sorted Lists (A very important question. hard. use priority queue. Definitely re-do and see the last solution!!!!!!)

76. Minimum Window Substring (classic. have to re-do!!!!!! sliding window. first keep l and r at 0, and then slide r, after satisfication, slide l.)
Similar questions:
Substring with Concatenation of All Words (Hard)
Minimum Size Subarray Sum (Medium)
Sliding Window Maximum (Hard)
Permutation in String (Medium)
Smallest Range Covering Elements from K Lists (Hard)
Minimum Window Subsequence (Hard)

273. Integer to English Words (High freq. Very good practise. Re-do!)
227. Basic Calculator II (Definitely re-do!!! Strategy: seperate first based on "+-", and then based on "*/". Note that for "*/", it needs to go from back to front! It is slow! Look at the given solution!)
528. Random Pick with Weight (Convert to range of intervals and then use binary search to find the solution! Did not figure out the solution. Definitely re-do!!!)
1396. Design Underground System (The logic was wrong because one ID can in and out multiple times! Have to review and re-do!!!!!!)
92. Reverse Linked List II (What should I say. This is of highest priority. Have to re-do!!!!!!)
211. Design Add and Search Words Data Structure (A Classic and Very Important Trie problem!!!!!! Have to re-do several times!!!)
797. All Paths From Source to Target (This is a very important graph problem! Back tracking. Re-do!!!!!! Also maybe do it later using DP.)
722. Remove Comments (A very important problem. Did not figure out the solution. Re-do!!!)
752. Open the Lock (Breadth-First Search. Have to re-do!!! Made so many mistakes!)
417. Pacific Atlantic Water Flow (It is a very hard and classic problem!!! Highest priority. Re-do!!! The trick is from edges to inner land! Adjacent cells have to be same or higher than current.)
388. Longest Absolute File Path (This problem is pretty hard and very important! Made so many mistakes! The key is to use stack! Definitely re-do!)
332. Reconstruct Itinerary (This is a very important and classic problem. Highest priority. The key is to sort the destinations and once found the result, directly return. Definitely re-do! Get familiar with two methods!)
210. Course Schedule II (This is one of the most important graph questions. Here DFS is used. The ordering is "Topological Sorted Order". Try to figure out the complexities. And try to understand another solution. Definitely re-do!!!)
210. Course Schedule II (Method 2: Node Indegree (BFS))
207. Course Schedule (The same idea as 210 but simpler since it does not require to get the order.)
846. Hand of Straights (A Google problem. Very Important and Very good Practise on iterating through the container at the same time deleting elements. Needs to do it well on C++, Java, and Python! Re-do!)
777. Swap Adjacent in LR String (A Google problem. High frequency. Very important! Re-do!!! First check: Without X, the number and relative sequence of X and R cannot change. Second check: L can only go left, and R can only go right. If L in start is smaller than L in end, it will fail. Similarly, if R in start is bigger than R in end, it will fail.)
444. Sequence Reconstruction (This is a hard and one of the most important questions related to graph and indegree method. Definitely re-do!!!!!!)
1202. Smallest String With Swaps (This is one of the most important questions for union find! Using graph is slow because it uses set! Re-do! Note the C++ optimized solution!!!)
901. Online Stock Span (A very important question. Use stack and did not figure it out. Re-do!!!!!!)
1049. Last Stone Weight II (This is one of the most important questions! Get familiar of this one and similar questions. See the independent post I generate. Do not need to say more. Re-do!!!!!!)
241. Different Ways to Add Parentheses (what a classic and important problem! Highest priority. Did not figure it out. Re-do!!!)
457. Circular Array Loop (this problem is extremely hard for me. I give the elements flags. Each time I increment the flags for different loops. I cannot get O(1) extra space though! Look at the given solution later. It is slow/fast pointer!!! Definitely re-do!!!!!!)
222 (*****). Count Complete Tree Nodes (This is one of the most important problem! And hard! It uses two binary searches. One is to identify the right most node (right most binary search), and the other is to identify whether the node is available in the tree (general binary search). Note the use of binary tree to see whether the node is there!!! Definitely re-do!!!!!!)
1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold (One of the most important problems. 2D presum and then right most binary search. A Google problem. Definitely re-do!!!)

40. Combination Sum II (A very very important backtracking problem. The line 'if(i > index && candidates[i] == candidates[i-1]) continue;' is the key!!!!!! Re-do!!!!!! Time complexity is O(2^n). Space complexity O(n). Basically, for each num you have two choices, pick it or not.)
https://leetcode.com/problems/combination-sum-ii/discuss/16878/Combination-Sum-I-II-and-III-Java-solution-(see-the-similarities-yourself)
All the similar problems are introduced in the thread above. Re-do!!!!!!
843. Guess the Word (This problem is an interactive problem. My solution was gotten kind out of luck. The correct way is to find the word with least number of 0 matches and every round choose that! Re-do!)
373. Find K Pairs with Smallest Sums (This is one of the most important problems. The idea is from 23. Merge k Sorted Lists. For priority_queue, the complexity for push and pop is in log scale. Definitely re-do!!!)
23. Merge k Sorted Lists (This is one of the most important questions. Notice the way to generate a new list!!!!!! And notice the use of priority_queue to solve the problem! Re-do! Similar to 373.)
767. Reorganize String (This is a very important problem! I did it the second time and did not figure it out again! Re-do! Previous comment: 767. Reorganize String (a very important problem! Did not figure out the solution at the beginning at all. Have to re-do!!! trick: from 1 to ..., and then from 0 to ... if a char is larger than (N + 1) / 2. no such solution...))
727. Minimum Window Subsequence (One of the most important problems! Definitely re-do! Two pointers or DP. I did not get the DP solution.)
1135. Connecting Cities With Minimum Cost (Krushkal's algorithm implemented by sorting and union find. Very important. Did not see this kind of graph problem before. Re-do!!! Note that for sort, give reference in lambda function can significantly improve speed!)
1153. String Transforms Into Another String (Hard! The idea is to see whether a spare letter can be found. 
        If found, a->b->c->d, it is OK, as we can start from d.
        If found, a->b->c->b, it is also Ok, as we can first change a -> c, and then c -> a.
        The key is that there is one letter which does not have incoming edge!!!
        Also, one letter cannot be changed to two different letters!!!
        Remember and re-do!)
1192. Critical Connections in a Network (The method is slow... Altough it works fine and I like the solution! Maybe re-visit to see better solutions? It increments the depth of the nodes, and if found the ada depth is smaller than current node, erase the edge. The depth is obtained by the returned value.)
1102. Path With Maximum Minimum Value (union find. What a great problem and solution! Go through the elements from higher value to lower value. When both are there, connect them. Stop until 0 and m*n - 1 are connected. Did not figure out. Dijkstra's method has to be understood also. The Python solutions in the Discuss is awsome!!!!!! Have to re-do!!!!!!)
260. Single Number III (
        //The key is that 1. a ^ b will keep the difference. 2. a & (-a) will keep the right most bit, 3. (a ^ b) ^ a = b or (a ^ b) ^ b = a, and the logic is as follows:
        //First, go through all nums to find the diff (bit)
        //Second, use bit & (-bit) to find the right most difference bit
        //Third, go through all nums again, if it has non-zero bit in the right most difference bit, do xor operation
        //Fourth, the xor operation cancels the ones with 2 nums, and only leaves the desired one with the right most difference bit non zero (x).
        //Fifth, use bit ^ x to find the other num (y).
        //Bit manipulation. Definitely re-do!!! Highest priority.
)
137. Single Number II (see https://lenchen.medium.com/leetcode-137-single-number-ii-31af98b0f462 and the derivations in my solution. Very important!)
780. Reaching Points (back track the numbers from target to source. Did not figure out the solution. Re-do!!!!!!)
1368. Minimum Cost to Make at Least One Valid Path in a Grid (Quite slow. Not a satisifying solution. Review 1102 Dijkstra and then this!!! Re-do!!!)
301. Remove Invalid Parentheses (Top priority!!!!!! Can understand the solution. It is extremely hard! Definitely re-do and re-do!!!!!! Can do backtracking later.)
19. Remove Nth Node From End of List (Method 1: two pass: from left to right, it is L - n + 1. OMG. This is a very very very import linked list problem!!! Method 2: Fake one pass solution:) Get familiar with both solutions! Very good practise!)
749. Contain Virus (Several key points: 1. The most dangerous one is the one with most adjacent cells instead of walls! 2. My algorithm is quite slow. Next time, I can obtain the cells in danger and regions simultaneously to speedup!!!)
128. Longest Consecutive Sequence (bravo. Just use hash and for each streak head keep on finding. Did not figure it out. Re-do!!!)
825. Friends Of Appropriate Ages (I used sort which is pretty slow. Another solution is using presum and some math like B > 0.5 * A + 7 and B <= A -> ... A Facebook high frequency problem. Re-do!!!!!!)
536. Construct Binary Tree from String (my solution is slow!!! Look at the given C++ solution which is very clean and one pass! Definitely re-do!!!!!! A very important tree and string problem!!!!!!)
802. Find Eventual Safe States (my strategy: 0: not evaluated; 1: already given a flag; 2: end; -1: already judged to be unsafe!!! Took too long to finish. Very important!!! Re-do!!!)
1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance (used Dijkstra's algorithm to find the shortest path to one source, and then repeat n times. very slow and a lot of repeated work. See the Floyd-Warshall's algorithm and re-do!)
295. Find Median from Data Stream (I did not figure out the solution at all! By using two heaps. Note that for C++ it is maxheap. Also, it is possible that the interviewer will ask for other solutions! See the other binary search solution. Definitely re-do!!!!!!)
886. Possible Bipartition (A very good question! Did not figure it out in the first place. DFS. With depth change, the flag is alternating. If found conflict, return false! Can re-do or get familiar with the algorithm!)
*****712. Minimum ASCII Delete Sum for Two Strings (Very classic!!! One of the most important DP questions! Do not need to say more. Re-do!!!!!!)
1143. Longest Common Subsequence (Also very classic. But a little easier than 712. Very good practise!!!!!!)
*****904. Fruit Into Baskets (One of the most important two pointers problem!!!!!! Longest sub-array with K different types of numbers!!!!!! Re-do!!!!!!!!!)
*****1055. Shortest Way to Form String (My top-down DP method is pretty awkward and slow! The greedy method is hard to me!!! Top-Priority. Have to re-do!!!!!!)
****1504. Count Submatrices With All Ones (The brute force way works pretty well!!! Get familiar with this! I failed it during mock interview. Re-do!!!!!!)
759. Employee Free Time (A very good heap question. Designated as hard. I did not figure it out at all! The trick is to use heap to save all the intervals. and then get the free time one by one by heap pop. Re-do!!!!!!)
516. Longest Palindromic Subsequence
(
  A very important DP problem. I did not get it at all!!! Since it is Palindrome, the logic is that:
  if s[i] == s[j]:
        dp[i][j] = dp[i + 1][j - 1] + 2
  else
        dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
  Re-do!!!!!!        
)
****1255. Maximum Score Words Formed by Letters
(
        Hard! One of the most important backtracking problems! The time complexity is 2^words.size(). There are two places confused me:
        1. The time complexity should not be factorial of words.size(), i.e. workds.size()!. The reason is that the factorial is for permutation of all the possibilities of words, and the sequence matters! The 2^words.size() is to decide whether choose a word or not!
        2. For backtracking, the implementation is:
          for (int i = index; i < words.length; i++){, in which index increments in every recursive call! Remember the pattern!
)
1274. Number of Ships in a Rectangle (Designated as hard. Note that the assertion below needs to be added. The time complexity is max(log(M), log(N))?)
646. Maximum Length of Pair Chain (greedy! Great! I thought out DP solution based on first element sort. It is O(n^2). The greedy approach first sort the array based on the second element and it is O(nlog(n))! Re-do!!!)
*****1463. Cherry Pickup II (This is hard!!!!!! Two tricky parts: 1. The states should be [m][n][n]. 2. The state should accumulate from the last row back to the first row, and the returned state should be dp[0][0][n - 1] as the starting locations have to be at col 0 and n - 1 respectively!!! Did not work it out at all. One of the most important questions. Re-do!!!!!!)
*****669. Trim a Binary Search Tree (This is designated as easy but it is not! Re-do!!!)
431. Encode N-ary Tree to Binary Tree (This is a hard tree problem!!! Did not figure it out! Made so many mistakes!!! Re-do!!!)
885. Spiral Matrix III (Did not figure it out at all!!! Re-do!!!)
********1405. Longest Happy String (This is extremely hard and the solution is extremely elegant!!!!!!! One of the most important questions! Re-do, re-do, re-do!!!!!!)
*****489. Robot Room Cleaner (This is hard!!! I did not figure out the solution. Using DFS can solve it! A very good DFS problem! Re-do!!!!!!!!!!!!!!!)
********337. House Robber III (One of the most important tree problems!!! The tree should concentrate on the current root!!! There is another way which returns a single max value with memoization! Re-do!!!!!!)
*****1140. Stone Game II (This is a very classic top-down DP problem. Did not figure it out. Re-do!!!!!!)
********1028. Recover a Tree From Preorder Traversal (Hard!!! What a great solution!!!!!! Highest priority!!!!!! It uses stack to generate the tree!!!!!! Did not figure out the solution at all!!! The most important stack and tree problem!!!)
1026. Maximum Difference Between Node and Ancestor (I used bottom-up approach. The given solution used top-down approach. The trick is the max min it can get either from bottom up or top down.)
1235. Maximum Profit in Job Scheduling (This problem is hard and the solution really rocks. One of the most important questions!!!!!! It is DP and uses map. Re-do!!!!!!)
616. Add Bold Tag in String (The problem needs attention! Would have been failed!!!!!! Same as 758! It uses flag to mark the bold indexes!!! The time complexity is O(n * m). Re-do!!!!!!)
384. Shuffle an Array (this is the interview random reshuffle problem which I failed in the interview.)
277. Find the Celebrity (My way of solving it is brute-force with some kind of optimizations. There is a O(n) way. One pass check and we know whether it is a potential candidate. Needs to Re-do, Re-do, and Re-do!!!!!!)
726. Number of Atoms (Designated as hard. Just be careful and do not make mistakes! Recursively solve it. For each recursion, it can either start with '(' or letter. Each upper case letter starts a new atom.)
428. Serialize and Deserialize N-ary Tree (Hard and Fun!!! This is a great question! I used DFS pre-order to serialize the nodes, and then I used stack to de-serialize it! Definitely study the other methods!!!!!!)
297. Serialize and Deserialize Binary Tree (This problem is not the same as the N-ary tree problem!!! The reason is that we need to know whether the node belongs to the left or the right sub node! As such, I introduced one more degree to output whether it is left or right, i.e. (val, dir, depth). I again used pre-order DFS to do it and it is kind of slow. Check out the solutions and re-do!!!!!!)
403. Frog Jump (Designated as hard. I used priority_queue. It works well! And I believe the time complexity is O(n * 3) = O(n).)
435. Non-overlapping Intervals (Very important!!! Same algorithm as in 1235. Maximum Profit in Job Scheduling. One of the most important interval problems. Also, see the one in the discussions!!! Re-do!!!)
********834. Sum of Distances in Tree (This is hard and one of the most important problems!!!!!!! I did not figure out the solution!!!!!!!! It is unconventional tree, and the problem is solved by post order first to get the sum based on the chosen root. And then it uses pre-order to get the sum of the children!!!!!!!! Amazing!!!!!!!!)
********471. Encode String with Shortest Length （There are two reasonings: 1. dp[i][j] = dp[i][k] + dp[k+1][j] in which k = i to j - 1 2. dp[i][j] can be represented by some repeated pattern which can be shorter. It is very tricky here! The repeated pattern corresponds to the original substring, and if repeated pattern is found, the substring is replaced by the dp. Oh my goodness!!!!!! This is one of the most important dp and string problem!!!!!! Re-do!!!!!!）
********1326. Minimum Number of Taps to Open to Water a Garden (Hard!!! One of the most important DP problems!!!!!! Re-do!!! Basically it initialize the dp with big number and go through 0 to n to see whether can find smaller numbers.)
********828. Count Unique Characters of All Substrings of a Given String (Hard!!! One of the most important problems!!! Salute to Lee for his solution! Re-do!!!!!!)
1029. Two City Scheduling (Did not figure it out. Should have been straitforward. Greedy. Re-do!!!)
239. Sliding Window Maximum (Hard. Use a deque to save the indexes. If the previous indexes are out of range, pop_front the previous indexes. And if the previous elements are smaller than the current elements, pop_back them. Therefore, the front of the deque always keeps the max element!!!!!! And the amortized time complexity is O(n)!!!!!! I only figured out a O(nlog(k)) solution and did not figure out this solution. Definitely get familiar with this and Re-do!!!!!!)
1239. Maximum Length of a Concatenated String with Unique Characters (Backtracking solves this. Time complexity: O(2^arr.size()). Do not make indexing errors (e.g. do not mistakenly use index + 1 for i + 1). Lee's solution is amazing. A classic example of bit manipulation and dp. This dp algorithm achieves the same effect of backtracking for all 2^arr.size() cases. Re-do following Lee's algorithm!!!!!!)
********920. Number of Music Playlists (Hard!!!!!! Top priority. One of the most important questions. It is extremely hard for me to derive the DP relationships!!! Definitely re-do!!!!!!)
****43. Multiply Strings (My solution uses map which is slow. Definitely try the one in the discussions!!! Re-do!!!!!!)
*********741. Cherry Pickup (This is extremely hard. One of the hardest problem!!! Defintely re-do!!!)
*********140. Word Break II (This is one of the hardest problems I encountered!!! The main reason is that a lot of my previous submissions are TLE. It has to use DP and it uses unordered_map to save the dp. Definitely re-do!!!!!! And get familiar with the complexities !!!!!! (Time: N^2 + 2^N + W; Space: 2^N * N + N^2 + W))
****1163. Last Substring in Lexicographical Order (Hard. My idea is to only check the positions with the largest char and also the longest following length of the largest char. It is kind of slow. The solution in the discussion is amazing! But I don't think I can remember the solution!!!)
****151. Reverse Words in a String (If the solution should be in-place and O(1) extra space. It is hard! This is a very good problem to implement insert on a string. The time complexity is O(N) where N is the length of the new string. It seems "result.insert(0, token + " ");" and "result = token + " " + result;" are of the same time complexity, but the former is faster!)
*********494. Target Sum (Highest priority!!! A classic 0/1 Knapsack DP problem!!! Definitely re-do!!! The way of handling 2^n possibility is great!!!!!! In addition, the explanation in the discussion is great!!! Also, note the time and space complexities!!!!!!
Time complexity: O(l * n). l referes to the range of sum and n refers to the size of nums array.
Space complexity: O(l * n). The depth of recursion can go upto n. The dp array contains l * n elements. )
*****1383. Maximum Performance of a Team (Hard!!! First sort it based on efficiency, and then maintain a priority q of length up to k. A very good question. Did not figure it out. Definitely re-do!!!)

//A similar problem bundle
********1723. Find Minimum Time to Finish All Jobs (Hard. Failed in the contest. Re-do!!!!!! DFS with branch cuttings. Maybe see other solutions. As seen in the discussion, 
Two other similar questions are
https://leetcode.com/problems/matchsticks-to-square/
https://leetcode.com/problems/partition-to-k-equal-sum-subsets/)
********698. Partition to K Equal Sum Subsets (This problem is very very important!!! It has two ways of solving: The first is that at each depth, we go through the nums to fill a bucket of size sum(nums) / k. The time complexity is k * 2^nums.size().
        //The second solution is that at each depth (fixed nums index), we go through the k buckets to see whether we can find k equal buckets. The time complexity is k^nums.size(). As it is of higher computational demanding, it definitely needs pre-sort and some branch cutting!!!
        //Definitely re-do and get familiar with such kind of problems!!!!!!)
********416. Partition Equal Subset Sum (It uses dfs, branch cutting, pre-sort (seems not very effective), and dynamic programming. It is only two buckets so that dp is easier. However, it seems it is a kind of knapsack problem. Get familiar with other solutions and definitely re-do!!!)
//A similar problem bundle

*********315. Count of Smaller Numbers After Self (Hard. It used merge sort. One of the most important questions. I did not figure out the solution and I don't think I can re-produce the succuess. Definitely re-do!!!!!!)
*****114. Flatten Binary Tree to Linked List (I used queue to solve the problem. It was more time consuming and needs more space. The given solution is amazing! It reversed the pre-order and then assign the root's right with the previous root. The concept is great! Definitely re-do!!!)
********218. The Skyline Problem (Hard! One of the most important problems! Use the idea in the linke below and a multiset solves the problem. The key is to seprate the buildings into start and end lines. The code developed by me beats 99% of the other codes!!! Very proud of myself!!! But defintely re-do!!! https://www.youtube.com/watch?v=GSBLe8cKu0s&feature=youtu.be)

//sort!!!
********912. Sort an Array (

It is important as it is basic! I used merge sort. 

Merge Sort is a stable sort which means that the same element in an array maintain their original positions with respect to each other. Overall time complexity of Merge sort is O(nLogn). It is more efficient as it is in worst case also the runtime is O(nlogn) The space complexity of Merge sort is O(n).
        //A sorting algorithm is said to be stable if two objects with equal keys appear in the same order in sorted output as they appear in the input array to be sorted. Some sorting algorithms are stable by nature like Insertion sort, Merge Sort, Bubble Sort, etc. And some sorting algorithms are not, like Heap Sort, Quick Sort, etc.
        //Definitely re-do by using other algorithms!!!
)
//sort!!!
******567. Permutation in String (Two pointers solve the problem!!! Only after I saw related topics I figured out the two pointers solution. This problem is very important. Have to re-do and re-do!!!)
**********312. Burst Balloons (This is a super hard problem!!! Did not figure out the solution at all and did not even write the solution!!! Definitely re-do!!)
********316. Remove Duplicate Letters (This problem is hard! Highest priority. Did not figure out the solution! Altough it is designated as medium. Definitely re-do and re-do. Also, the trick is that if the char has alreay been visited, do not consider it any longer!)
********1727. Largest Submatrix With Rearrangements (I failed it in the contest. Designated as medium but I think it is pretty hard! One of the most important questions. Definitely re-do!!!)
**********1728. Cat and Mouse II (This is the hardest problem I have ever encountered. In addition to that I think the time limit is too strict! Definitely re-do!!!!!!)
******1027. Longest Arithmetic Subsequence (I did not figure out the solution. Very important. Definitely re-do!!!)
********679. 24 Game (Hard!!! A very important problem!!! Did not figure out the solution. In each recursive call, a new list is generated and the length of the list keeps on decreasing!!! Re-do!!!)
****386. Lexicographical Numbers (The solution in the discussion is amazing!!! I did not figure it out!!! The problem is important!!! Have to re-do!!!)
****363. Max Sum of Rectangle No Larger Than K (Hard. A brute force way was used and accepted. Will see the solution later! Defintely re-do!)
****678. Valid Parenthesis String (My solution was quite slow!!! See the given solution and re-do!!!)
****173. Binary Search Tree Iterator (The stack solution is amazing for iterating through the BST. I did not figure out the solution!!! Re-do!!!)
******545. Boundary of Binary Tree (This is one of the most important tree problem. Did not figure out the solution. Definitely re-do!!!)
********341. Flatten Nested List Iterator (I believe it is one of the most important iterator problems!!! I failed to solve it. Definitely re-do!!!)
************Have to re-do!***************

8. very important re-visit problems:
(R) 1042. Flower Planting With No Adjacent (The problem is not easy! Did not figure out the solution. re-do!!! The logic is go through the gardens, and see what colors its neighbors have already chosen. After that, just choose the remainging one!)
(R) 1062. Longest Repeating Substring (the current solution is pretty slow although can pass. Re-do! Reference the given solution.)
1023. Camelcase Matching (string and trie?????)
357. Count Numbers with Unique Digits (failed to solve. Two approaches. Re-do!!!!)
(R (second time did not work out)) 279. Perfect Squares (dynamic programming! do not make mistakes. re-do! Time complexity is O(n * sqrt(n)). I did not work it out the second time! The reason is that I only need to consider the previous ones which are squares!)
729. My Calendar I (my lord. I had no clue at all! very hard to me! use set and lower_bound. re-do!!!!)
991. Broken Calculator (failed to work it out. very important. re-do!!!)
313. Super Ugly Number (had no clue at all!!!)
1072. Flip Columns For Maximum Number of Equal Rows (XOR. No clue at all. re-do!!!)
253. Meeting Rooms II (a very important problem. the idea is that first sort, and then keep track of the current first with the previously stored second interval by using upper_bound. time complexity?)
705. Design HashSet (it seems like I failed to design it. re-do!!!)
1248. Count Number of Nice Subarrays (failed to do. re-do!!!!!!)
1588. Sum of All Odd Length Subarrays (do not use brute force. re-do!!!!)
640. Solve the Equation (so complicated! it can be x, or 2x. made so many mistakes. re-do!)
523. Continuous Subarray Sum (very easy to make mistakes. Did not figure out first. re-do!!!!)
974. Subarray Sums Divisible by K (clasic! use hash map to solve! re-do! reference problem 523!)
11. Container With Most Water (Classic two pointer problem. The key is to move the shorter line every time because: If we try to move the pointer at the longer line inwards, we won't gain any increase in area, since it is limited by the shorter line. But moving the shorter line's pointer could turn out to be beneficial, as per the same argument, despite the reduction in the width.)
56. Merge Intervals (A classic interval problem! Be careful. Do not make mistakes! re-do!!! Note that the previous interval is evolving! Many companies tested this!)
1498. Number of Subsequences That Satisfy the Given Sum Condition (Classic! Classic! Classic! Classic two pointer problem! re-do!!!!!)
274. H-Index (visualize it. The key is to find the biggest i such that citations[i] > i. a key problem. re-do!!!)
57. Insert Interval (Try the solution in discussions. Three sections using while. Much clearer!)
560. Subarray Sum Equals K (classic, classic, classic! Have to re-do!!!)
1218. Longest Arithmetic Subsequence of Given Difference (classic!!! re-do!!! use hash table as dynamic programming!!!)
548. Split Array with Equal Sum (Did not figure out the solution. First find the middle one, and then loop through first half and see equal. and then loop through second half and see whether can find the same equal by using hash set. O(n^2))
1202. Smallest String With Swaps (a graph problem. do it later!!!!!!)
916. Word Subsets (note that for A to pass all B, it needs to have all distinct letter's max freq among B. I did not figure out the solution. re-do!!!!)
90. Subsets II (this problem is classic! re-do!!! here the subset is not necessarily continuous and sequential!!! And e.g. (1,4,4) and (4,1,4) are the same. what is a power set?????!!!!!)
259. 3Sum Smaller (my solution is slow. See the two pointer solution in the discussions! Classic!!! re-do!!!)
795. Number of Subarrays with Bounded Maximum (a dynamic programming (dp) problem. very hard!!!!!!! the tricky part is that when the previous is less than L, needs to add all of them.)
945. Minimum Increment to Make Array Unique (I did not figure out the solution. re-do!!!! the strategy is important. Without knowing the strategy, it cannot be solved. The strategy is that first sort, and then if A[i] <= A[i - 1], update A[i] to be A[i - 1] + 1.)
809. Expressive Words (problem can be solved by two pointers! a very good problem to consider corner conditions, i.e. beginning and end!!! re-do at some point!!!)
1046. Last Stone Weight (what a classic problem for priority_queue!!!!!! I did not figure out the solution. re-do!!!!!! Can also be done by using std::set? Probably yes.)
1518. Water Bottles (not hard, but very easy to make mistakes. re-do!)
313. Super Ugly Number (amazing but I did not figure out the solution at all!!!!! have to re-do!!!!!! classic!!!!!!!)
264. Ugly Number II (the same as problem 313. very important!)
1605. Find Valid Matrix Given Row and Column Sums (I did not figure out the solution. Greedy! re-do!!!!!!!!)
1513. Number of Substrings With Only 1s (change the string to intervals of 1 and add them up. The tricky part is that two relatively small numbers can multiply into a number which is overflow. Look at the given solution in the discussion. So elegant!!!!!!)
634. Find the Derangement of An Array (a dynamic programming problem!!! my goodness. For dynamic problem, the formula is the key! a classic problem. Did not figure out the solution. re-do!!!!)
983. Minimum Cost For Tickets (classic dynamic programming problem!!! Look at the usage of max(0, i) and min({a, b, c}), classic! Did not figure out the solution. Over thought about it. Re-do!!!)
1504. Count Submatrices With All Ones (failed again. very hard!!!!!!!!!!! do it later!!!!!!!!!!!!!!!!!)
881. Boats to Save People (Classic two pointers algorithm. the strategy is to pair heaviest and lightest. If not satisfy, only carry the heaviest... Use two pointers.)
424. Longest Repeating Character Replacement (Classic. A very very very important two pointer problem. Did not figure out the solution. re-do!!!!!!!)
487. Max Consecutive Ones II (similar to problem 424. Very important and classic!!!!!!!!!!!!!!!!)
325. Maximum Size Subarray Sum Equals k (made way tooooooo many mistakes!!!!!! re-do!!!!!!!!!!)
525. Contiguous Array (Classic hash table problem!!! worth re-do!!!!!!)
1419. Minimum Number of Frogs Croaking (the problem is classic!!!!!!! A very good interval problem and get the minimal re-usable intervals!!!!!! re-do!!!!!! find_first_not_of used here.)
484. Find Permutation (the trick is that first construct a vector, and then locally reverse based on how many 'D' there are and go forward.)
478. Generate Random Point in a Circle (simply re-do!)
1144. Decrease Elements To Make Array Zigzag (Do each case (even indexed is greater, odd indexed is greater) separately. In say the even case, you should decrease each even-indexed element until it is lower than its immediate neighbors. Note that it needs to be lower than its immediate neighbors!!!!!! I did not figure out the solution at all. zigzag. Re-do!!!!!!)
153. Find Minimum in Rotated Sorted Array (this seems like an important question as a lot of the companies tested this. However, I used my way to solve it. May re-visit later.)
120. Triangle (I can actually use zero extra space for this! Good job!)
1019. Next Greater Node In Linked List (The next greated element. Classic!!!!!! Did not figure out the solution. Use stack! Re-do!!!)
503. Next Greater Element II (Classic. Similar to problem 1019. Use stack to solve it. As it can be circular, pre stack the elements from end to start.)
755. Pour Water (Classic. note the key is to find the lowest to left and right respectively. Another key is that if found higher, it needs to stop.)
73. Set Matrix Zeroes (save the row and col info at first col and first row respectively. The (0, 0) can be confusing. Save first row and col info differently. re-do!)
328. Odd Even Linked List (made so many mistakes. The main issue is indexing. re-do!!!!)
430. Flatten a Multilevel Doubly Linked List (my goodness. made so many mistakes. have to re-do!!!!!!!!!!! 1. auto head_copy = head; (a new pointer is generated) 2. When the equal sign is there, the pointer is not modified and it points to a new content! 3. Needs to clean up the children.)
725. Split Linked List in Parts (Made so many mistakes! re-do!!!!!! The essense of the problem: Distribute the numbers with adjacent difference at most 1. The left is greater than the right. Just n / k and from left to right add 1. For each part, the next of the end element needs to point to nullptr.)
162. Find Peak Element (classic. binary search. re-do!!! The key is that the two ends are potentially the peak.)
79. 79. Word Search (Failed to solve (re-do!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!))
50. Pow(x, n) (interesting. re-do!!!!!!)
24. Swap Nodes in Pairs (a very very very import list question. Made so many mistakes. re-do!!!!!!)
1485. Clone Binary Tree With Random Pointer (only one hash map can solve it. re-do!!!!!!)
979. Distribute Coins in Binary Tree (classic. What should I say... Have to re-do!!!)
1457. Pseudo-Palindromic Paths in a Binary Tree (can use bit manipulation to solve it. re-do!!!!!!)
1110. Delete Nodes And Return Forest (A very good question. Google problem. The key is once found to be deleted node, push back its children. Do not forget to push back the root in the end. Also, to delete a node, the recursive method needs to have reference of pointer.)
1123. Lowest Common Ancestor of Deepest Leaves (Tree problem. A very important question!!!!!!!!! The key is that if both left and right contains the deepest leaf, it is the closest ancestor. Keep on updating until it finds the newest one which is the answer.)
5. Longest Palindromic Substring (A very important string question. Method 1: go through elements of s and calculate whether palindrome. ***Do method 2 later using dynamic programming!!!!!!)
15. 3Sum (just be careful! very important. re-do later!)
109. Convert Sorted List to Binary Search Tree (my solution is quite different from the given solutions! Check the ones in the discussion!!! This is a classic problem! The key is convert to two sub problems and for each given begin and end. The stop criterion is that when begin > end.)
91. Decode Ways (a dynamic programming problem. very easy to make mistakes, '0' is a special case. re-do!!!!!!)
394. Decode String (a very good practise. Same the beginning and endding locations of the brackests. Recursively add the strings.)
221. Maximal Square (a very very very important dynamic programming question. remember the equation and re-do!!!!!!)
31. Next Permutation (A very important question. I believe that I did not do it in a correct way. Have to re-do and see the solutions in the discussion.)
1130. Minimum Cost Tree From Leaf Values (A very important question. I did not do it in a correct way. Have to re-do and see the stack solutions in the discussion.)
322. Coin Change (a very good and important dynamic programming problem. If there is no solution, dp[i] = -1.)
79. Word Search (Running time is very important. This example shows this well. In in-order, it replaces the board, and in post-order, it replaces it back!!!!!! Very classic. Re-do or review this!!!)
54. Spiral Matrix (just follow the rule.)
127. Word Ladder (A classic BSF problem!!!!!! depth search is too costly. Use BSF can guarantee to arrive in shortest path!!!!!! do it later!!!!!!)
199. Binary Tree Right Side View (BSF can solve this. Every time, push back the queue's last element.)
127. Word Ladder (Classic; shortest path; BFS)
138. Copy List with Random Pointer (High frequency. Use an unordered_map can solve such kind of random pointer problem. The hash is from old to new.)
139. Word Break (Classic and high frequency! a BFS is slow! Use Dynamic programming!)
518. Coin Change 2 (A high frequency problem. A classic dynamic programming problem. Did not figure out the solution. Have to re-do!!!!!!!!!!! The trick is that loop the coin first!!!)
300. Longest Increasing Subsequence (A high frequency problem. What should I say. The solution is very unique. I am afraid that I cannot remember it long term. Practise more. Definitely re-do!!!!!!)
1283. Find the Smallest Divisor Given a Threshold (High frequency and very good practise. A binary search problem. Find the left most solution.)
34. Find First and Last Position of Element in Sorted Array (Classic!!! can re-do. Binary search, first use lower bound and then find the right most ele.)
98. Validate Binary Search Tree (good practise. use return && && to solve the in-order problem.)
738. Monotone Increasing Digits (Re-do!!!!!! Be familiar with the logic.
        //The idea: compare the current digit with previous
        //if it is smaller, -1 on previous digit, and add all 9
        //if it is greater, add current digit
        //if it is the same, three conditions:
        //1. if the next non equal is greater, add current digit
        //2. if the next non equal is smaller, -1 on previous digit, and add all remaining 9
        //3. if the next non equal is always the same, return N directly.)
215. Kth Largest Element in an Array (I used priority_queue to solve the problem. Note that last given solution. Re-do.)
833. Find And Replace in String (A good practise. Know the idea. Get time then re-do! Relatively important because it is a Google problem.)
1423. Maximum Points You Can Obtain from Cards (A google problem. Just choose m and n from left and right respectively. And find the maximum among all the options.)
1146. Snapshot Array (A Google problem. a very very good practise for implementing bound on map directly. map can do iteration like iter--! map insert will not conduct if the key is already available! Re-do!)
1376. Time Needed to Inform All Employees (A very good problem which is solved by a tree like concept! A Google problem. re-think at least! The solution in the discussion is interesting, review.)
1477. Find Two Non-overlapping Sub-arrays Each With Target Sum (This is one of the most important problem!!!!! Have to re-do several times!!!!!)
721. Accounts Merge (This is a very important union find problem! Got some other faster solutions! See the C++ solution. Definitely re-do!)
934. Shortest Bridge (A very good problem! My strategy: first identify one of the island using DFS. And then use BFS to find the minimal layers! Can re-do!)
399. Evaluate Division (backtracking can solve it. A very good practise.)
526. Beautiful Arrangement (Backtracking can solve it. High frequency.)
1472. Design Browser History (use vector, all the operations are constant. (No! resize is not constant. Re-do!))
93. Restore IP Addresses (Backtracking. Be careful not to make mistakes. The last section needs to go all the way to the end.)
71. Simplify Path (Be careful not to make so many mistakes. while(pos < path.length()) is the key. If use while(pos != path.length()), pos may be greater than path.length. Worth Re-do!)
393. UTF-8 Validation (A very good big manipulation problem. C++ and Java are consistent in terms of binary representations!!! (e.g. 0b01101). Worth re-do!!!)
55. Jump Game (I believe that my solution is good. The key is to keep track of max index which can be reached, and if current index is bigger than max index can reach, it will fail.)
113. Path Sum II (Very important because first, when it goes back, the vector can pop_back so it is faster, and second, note that Java alwasy pass by value. But, reference is copied but it points to the same memory!!!!!!)
779. K-th Symbol in Grammar (The trick is to trace back the locations at each row, and then trace forward the number.)
959. Regions Cut By Slashes (DFS solves the problem. The trick is to split the element into four sub regions.)
861. Score After Flipping Matrix (Greedy. First change all rows' first element to 1, and then change the remaining columns.)
1578. Minimum Deletion Cost to Avoid Repeating Letters (a stack based algorithm solves this. Keep track of previous char and compare the costs.)
68. Text Justification (This is designated as a hard problem. A few points: 
          1. First put one word, and then space + another word, and space + another word...
          2. One word, condition 2
          3. More than one word, condition 2.1 common lines, and condition 2.2 last line
          Very good practise.)
1615. Maximal Network Rank (Note the use of vector <vector <int> > flag(n, vector <int>(n)) to judge whether the edge is there.)
1335. Minimum Difficulty of a Job Schedule (This is a dynamic programming (dp) hard problem!!! I only used the first solution in https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/490316/JavaC%2B%2BPython3-DP-O(nd)-Solution to solve it. Definitely re-do!!! Very important!!!)
1641. Count Sorted Vowel Strings (Given the words, add the letters alphabetically. For example, "aa" can add 'a', 'e', 'i', 'o', and 'u', and 'ae' can add 'e', 'i', 'o', 'u'. So that the last letter of the word matters. Re-do.)
980. Unique Paths III (Designated as hard. I use dfs and backtracking to solve it. Note that the time complexity is 3^N because in the worst case, we have to try 3 directions except for the source!)
1273. Delete Tree Nodes (Very good tree like practise!)
1105. Filling Bookcase Shelves (I used memoization (top-down) to solve it. Maybe look at the bottom-up method later.)
1402. Reducing Dishes (Designated as hard. The strategy is that first find the index for the element with value >= 0, and then go backward to the beginning. Do not make mistakes!)
1372. Longest ZigZag Path in a Binary Tree (Almost did not work out. The trick is to track the max length for all nodes instead of only the root!!! Can re-do!!!)
1066. Campus Bikes II (This is a great question! Combination of backtracking and DP. Note that for DP, the state can be (1 << M)!!! Can re-do!!! See the priority solution later!)
85. Maximal Rectangle (Designated as hard. Used the "number of rectanges" solution to solve it. May re-visit for the DP solution.)
407. Trapping Rain Water II (https://leetcode.com/problems/trapping-rain-water-ii/discuss/89461/Java-solution-using-PriorityQueue. See the above explanation again. Have to re-visit.)
124. Binary Tree Maximum Path Sum (designated as hard. For each node, return the max of (l + root -> val, r + root -> val, root -> val). The max_val is: max({max_val, l + root->val + r, l + root -> val, r + root->val, root->val}). As the number can be negative, so that the max can either be sub tree plus itself or just the value of the node itself.)
286. Walls and Gates (A very classic BFS problem. Use the gates as starting points to find the closest distance! Worth re-do!)
1229. Meeting Scheduler (For one array's each start point, find the closest end point of another array and see whether it can last the duration. It also needs to check another way around! Worth re-do!)
863. All Nodes Distance K in Binary Tree (First set up relationship between the node and its parent for all nodes. And then for the target node, the distance K is either for the nodes below the target or between the target and anyone below one of the parent of the target. The problem is tricky and it uses a hashmap. See the one in the discussions also! Definitely get familiar and re-do!!!!!!)
468. Validate IP Address (Very good string manipulation practise!!!)
1091. Shortest Path in Binary Matrix (DP and Dijkstra's algorithm solve this problem! Note that DFS cannot pass as it is very time consuming. Very good practise. Worth re-do!)
314. Binary Tree Vertical Order Traversal (Indexing col and depth when do pre-order DFS can solve the problem. Look at maybe better solutions later.)
102. Binary Tree Level Order Traversal (I used BFS to solve it. Get familiar with both BFS and recursion solutions! Not familiar with Java syntax. Very slow. Should practise Java more and more.)
1722. Minimize Hamming Distance After Swap Operations (The problem is encountered in the contest. I solved it using union find and multiset. However, the solution in the discussion can reduce it to unordered_multiset. The trick is to loop through the ones in the target, and if it is found in the unordered_set, it will erase it. In the contest, I was not familiar with parent stuff and set_difference. Get familiar with those knowledge again!!! Worth re-do!!!!!!)
622. Design Circular Queue (A good problem. The purpose of the problem is to implement array with changing first and last indexes. Worth re-do!!! Also note that using unique_ptr to initialize an array is:
        unique_ptr <int[]> array;
        array = unique_ptr <int[]>(new int[k]);)
1220. Count Vowels Permutation (Designated as hard. Just use bottom up DP which is straitforward to solve.)
845. Longest Mountain in Array (I solved it based on pointer technique. The trick is to identify the peak along the way and once found the peak the left and right most indexes are identified separately. It should be O(n). Very good question.)
1155. Number of Dice Rolls With Target Sum (dfs with memoization (top-down dp) solves the problem. Good practise. Worth re-do.)
472. Concatenated Words (Designated as hard. For each word, I used dfs with memoization to solve the problem. Be careful to not consider "" as it is not a word, although it is not clearly stated in the requirement. Worth re-do.)
436. Find Right Interval (binary search solves the problem. Note the use of lower_bound on vector of vector! May re-do for lower_bound on vector of vector.)
41. First Missing Positive (Designated as hard. Assign all the negative numbers to be 0. The logic is as follows: if the min pos number is not 1, return 1; if the min pos number is 1, go through all the nums, for the num within the element, go to the index of (num - 1), if the num is pos, change it to neg, and if the num is 0, change it to INT_MIN. And then go through the nums again, if the num is >=0, return index + 1. If it is not found, return nums.size() + 1.)
********************************************************************************

8. re-visit problems: 
1004. (sliding window) 
1237.
1446. Consecutive Characters
303. Range Sum Query - Immutable
696. Count Binary Substrings
1071. Greatest Common Divisor of Strings
1089. Duplicate Zeros (there is a better solution)
441. Arranging Coins
1539. Kth Missing Positive Number (next time resolve it using binary search)
1275. Find Winner on a Tic Tac Toe Game (good practice to consider the corner cases)
989. Add to Array-Form of Integer (notice the given solution method in Java)
937. Reorder Data in Log Files (a hard problem!)
507. Perfect Number (re-visit!)
168. Excel Sheet Column Title (interesting)
453. Minimum Moves to Equal Array Elements
189. Rotate Array (must try the O(1) extra space method!)
532. K-diff Pairs in an Array (notice that k can be <0, == 0, and > 0, and same numbers only count once)
414. Third Maximum Number (consider using one loop)
535. Encode and Decode TinyURL (what is tinyURL?)
953. Verifying an Alien Dictionary (compare adjacent string, re-do)
447. Number of Boomerangs (notice that for each point, generate a hash map)
299. Bulls and Cows (re-do, think about some faster method)
1556. Thousand Separator (make sure pass one time. 1. a_string.insert(position, count, char) 2. do not add '.' at position = 0)
1277. Count Square Submatrices with All Ones (dynamic programming, the 1D index one does not work because i, j are both updated! May look for better solutions in discussions?)
1433. Check If a String Can Break Another String (failed to work it out. Re-do!)
1104. Path In Zigzag Labelled Binary Tree (interesting, worth re-do)
1442. Count Triplets That Can Form Two Arrays of Equal XOR (definitely re-do, needs some derivations on XOR operations)
885. Spiral Matrix III (failed to work it out, re-do!)
338. Counting Bits (needs to re-visit sometime, remember the equation)
442. Find All Duplicates in an Array (re-do, two solutions, one is the one I figure out, the other is the solution in discussions)
969. Pancake Sorting (may worth re-do)
1338. Reduce Array Size to The Half (be careful, do not make mistakes)
877. Stone Game (failed to work out. Re-do! Dynamic programming dp(i, j), starts from dp(i,i) and then increase the i, j difference. Definitely worth re-doing)
1344. Angle Between Hands of a Clock (not hard, but be careful, do not mistake double to int, and each hour corresponds to 5 in the 60 circle)
1227. Airplane Seat Assignment Probability (dynamic programming problem. Although the solution is guessed. It is great if can derive later.)
1447. Simplified Fractions (from small to large number, if gcd(i,j) == 1 accumulate)
1017. Convert to Base -2 (remember the formula)
413. Arithmetic Slices (made too many mistakes, re-do)
665. Non-decreasing Array (definitely re-do, for i, first change (i - 1) if (i - 2) <= i, else change i == i - 1) 
1508. Range Sum of Sorted Subarray Sums (sliding window and do not make mistakes)
1362. Closest Divisors (be careful, do not make mistakes, priority_queue solution?)
553. Optimal Division (maybe understand the problem better?)
1233. Remove Sub-Folders from the Filesystem (I did not figure out this solution. Have to re-do.)
1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold (sliding window, note less or equal to, and note the overflow, can also be solved by presum)
1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (greedy approach; did not figure out the solution myself)
1375. Bulb Switcher III (two steps; keep track of the right most bulb; did not figure out the solution myself)
1566. Detect Pattern of Length M Repeated K or More Times (there is another O(n) solution)
1437. Check If All 1's Are at Least Length K Places Away (be careful not to make mistakes, may worth re-do)
1493. Longest Subarray of 1's After Deleting One Element (I have no idea about the solution!!! Resolve it later with the other sliding window problems!!!)
290. Word Pattern (made so many mistakes! Read solution)
762. Prime Number of Set Bits in Binary Representation (note the __builtin_popcount solution and the bitset<32>(i).count() solution)
781. Rabbits in Forest (note the use of map, key: total rabbits of same color, value: accumulated rabbits. Note that do not forget to add all the remaining map keys)
858. Mirror Reflection (I did not figure out this solution. This is done by mirroring the blocks. It needs some drawings and summary.)
963. Minimum Area Rectangle II (in my opinion, a hard problem. Have to remember to use centroid and diagonal length.)
1011. Capacity To Ship Packages Within D Days (a phenominon binary search problem. According to the discussions, similar problems are 

1482. Minimum Number of Days to Make m Bouquets
1283. Find the Smallest Divisor Given a Threshold
1231. Divide Chocolate
1011. Capacity To Ship Packages In N Days
875. Koko Eating Bananas
774. Minimize Max Distance to Gas Station
410. Split Array Largest Sum
)

1031. Maximum Sum of Two Non-Overlapping Subarrays (This question is worth re-do. Two pre_sum. Do not make mistakes.)
1267. Count Servers that Communicate (not hard but do not make mistakes, j and a_vector[i][j] are different! The solution in the discussions is great.)
48. Rotate Image (I did not figure out the solution. First top and bottom rows reverse. Second diagonal swap.)
1471. The k Strongest Values in an Array (Lession learned: 1. Read the problem statement carefully. The returned values are the arr elements. 2. Do not forget corner cases. In this case, arr.size() == 1.)
216. Combination Sum III (Failed to solve. Backtracking problem!!!!! Using my methods keep passing time limit. The key is to keep increasing the next element.
This is an important problem. Should try doing later several times.)
39. Combination Sum (worth re-do. Similar to problem 216.)
22. Generate Parentheses (worth re-do. Another backtracking problem.)
1111. Maximum Nesting Depth of Two Valid Parentheses Strings (Did not understand the problem. Re-do! The trick is to split even as much as possible. The odd and even parentheses are separated into A and B respectively.)
287. Find the Duplicate Number (my unique way of resolving it)
1249. Minimum Remove to Make Valid Parentheses (stack is used. sometimes slow down the writing can avoid a lot of logic and typo errors.)
856. Score of Parentheses (failed to solve. do not make mistakes. the trick: count number of '(', if found '(' and next is ')', add the score; if only found ')', decrease the number of '('.re-solve later!!!!!!)
1035. Uncrossed Lines (dynamic programming, I did not figure out the solution. Re-do!!!)
256. Paint House (dynamic programming, I did not figure out the solution. Re-do. The DP can be 2D!)
276. Paint Fence (dynamic programming, I did not figure out the solution. Re-do. Needs some derivations.)
1043. Partition Array for Maximum Sum (dynamic programming. I did not figure out the solution. This is a hard problem! The key is that for any element, goes back from 1 to k, and see which one is the largest. re-do!!!)
758. Bold Words in String (made so many mistakes!! re-do!!! a_string.find(another_string, start_position)!!! inserting something into a string is awlays a pain!)
1286. Iterator for Combination (very interesting problem for backtracking. Figured out myself. Do not forget return. Worth re-do.)
1198. Find Smallest Common Element in All Rows (Of lower priority to re-do. Use set_intersection to solve the problem. the container types need to be the same)
1056. Confusing Number (Of lower priority to re-do. Note that the rotation is not based on each digit but based on the entire number.)
370. Range Addition (range addition time complexity can be O(m + n). I did not work it out myself. A Google problem. Definitely worth re-do!!)
1151. Minimum Swaps to Group All 1's Together (classic sliding window problem! worth re-do! Do not make mistakes)
565. Array Nesting (I did not figure out the solution. The trick is that once the number is involed, it is no longer involved. Definitely do it again.)
311. Sparse Matrix Multiplication (there is obviously a better solution. re-do.)
1244. Design A Leaderboard (very slow. re-do!)
1256. Encode Number (a math problem, f(n) = f((n - 1) / 2) + "10"[n / 2])
1272. Remove Interval (just be careful. Google problem.)
1213. Intersection of Three Sorted Arrays (very good practise two two pointers. there is a better solution.)
763. Partition Labels (I did not figure out the solution. Definitely re-do!!!)
624. Maximum Distance in Arrays (I did not figure out the solution. Re-do!!)
245. Shortest Word Distance III (do not necessarily save position. re-do. But lower priority.)
1403. Minimum Subsequence in Non-Increasing Order (study the priority queue solution.)
1561. Maximum Number of Coins You Can Get (the trick is to let the third person take the last 1/3.)
1057. Campus Bikes (my original idea was sort based on set. It was out of time limit. The trick is that we know the distance range will be from 0 to 1998. may re-do.)
1006. Clumsy Factorial (the trick: first 3 elements, and then +, -, *, /. do not make mistakes.)
573. Squirrel Simulation (choose the first nut is the key. needs to consider not only the distance for the squirrel but also needs to consider the saved distance from the tree to the nut.)
462. Minimum Moves to Equal Array Elements II (I did not figure out the solution. The trick is to find the median element, not the average! The median is found by using nth_element algorithm. re-do!)
1109. Corporate Flight Bookings (a range sum problem. Do not make mistakes.)
1131. Maximum of Absolute Value Expression (did not figure out the solution. Do it later!)
1296. Divide Array in Sets of K Consecutive Numbers (it is a Google problem. It is highly easy to make mistakes. re-do!!! The next element may not be continuous. e.g. 1,2,3,5,6,7 (3 and 5 are not continuous) The given solution is to check the next k elements have the same frequency. may re-do using this!)
667. Beautiful Arrangement II (failed to solve. A Google problem. Solve it later! Definitely do it! Have solved it. Note that odd and even situations for k are different!!!)
1041. Robot Bounded In Circle (if flip direction or change 0, it is a circle. re-do if does not know the previous sentence.)
1358. Number of Substrings Containing All Three Characters (I did not figure out the solution and it is too slow! use sliding window to re-do it!!!)
592. Fraction Addition and Subtraction (use std::gcd, std::lcm. made so many mistakes. re-do!!!)
360. Sort Transformed Array (the key is that when a >= 0, the curve is high-low-high, and when a < 0, the curve is low-high-low. (when a = 0, it depends on how you choose next.) two pointers problem. re-do!!!)
1582. Special Positions in a Binary Matrix (what should I say... re-do. did not do it very well. Notice the given solution. Two passes. Similar to #531 lonely-pixel-i.)
1366. Rank Teams by Votes (very good sorting problem. re-do!)
648. Replace Words (the given solution is trie. Revisit later. Re-do.)
1452. People Whose List of Favorite Companies Is Not a Subset of Another List (sort beforehand can speed it up. re-do!)
1509. Minimum Difference Between Largest and Smallest Value in Three Moves (note all the possibilities)
1016. Binary String With Substrings Representing 1 To N (time: O(N * (log(N) + S)). space: O(log(N)). only needs to check N to N / 2, for i = 1 to N/2, N to N / 2 can incorporate them.)
1093. Statistics from a Large Sample (the median is obtained by pre_sum and current_sum. Even and odd conditions are tested. be careful.)
986. Interval List Intersections (two pointers. do not make mistakes. re-do! sometimes only found issues when the problematic case is given. what if it is not?)
1150. Check If a Number Is Majority Element in a Sorted Array (first use lower_bound to find the first appearance.)
1014. Best Sightseeing Pair (go through A[j] - j, and for each, find the previous max and add them together. re-do!)
926. Flip String to Monotone Increasing (go through from left to right, record how many 1s. go through from right to left, record how many 0s. Note that it is possible all 0s and all 1s.)
423. Reconstruct Original Digits from English (can first deduce the numbers with the unique letters.)
1418. Display Table of Food Orders in a Restaurant (the biggest issue for me to handle hash table is speed.)
524. Longest Word in Dictionary through Deleting (essense: from 'axdsfbsdfc', see whether 'abc' is a substring by deleting. categarize based on 26 letters, and then sequetially upper_bound the position in each category. re-do! made so many mistakes.)
75. Sort Colors (in place algorithm, mine is the fastest.)
1099. Two Sum Less Than K (look at the other solutions! re-do!!!)
611. Valid Triangle Number (could have been faster? re-do.)
593. Valid Square (the points can coincide, the length can be 1 or 2 or others, re-do)
1503. Last Moment Before All Ants Fall Out of a Plank (brainteaser!)
495. Teemo Attacking (check overlapping. Easy since the duration is constant.)
1185. Day of the Week (interesting. leap year: not 100 years, can be divide by 4; 100 years, can be divided by 400)
676. Implement Magic Dictionary (save the words without a letter into a hash map)
244. Shortest Word Distance II (do not make mistakes)
554. Brick Wall (the key is to use pre_sum and change the numbers into hash table.)
1598. Crawler Log Folder (use stack to solve it. It may not be straitforward if did not know using stack at the beginning.)
1381. Design a Stack With Increment Operation (take away: pop_back() returns void. cannot use pop_back() and back(), they indicate the last element of the entire vector. may or may not re-do)
921. Minimum Add to Make Parentheses Valid (use stack to solve this. extend the original string.)
1190. Reverse Substrings Between Each Pair of Parentheses (when encountered ')', pop until '(', and then push backwards. It is O(n^2). Look at Lee's solution, which is O(n). May re-do.)
1152. Analyze User Website Visit Pattern (it needs to clarify that: the timestamp is not sequential, the username is not sequential. the combination of three websites can be easily obtained by three loops)
1424. Diagonal Traverse II (use std::sort combined with lambda function to sort it.)
853. Car Fleet (the trick is to first sort the cars by position, and then loop from right to left. if the next car cannot catch the current one, the next car is the previous car. re-do.)
1288. Remove Covered Intervals (be careful. do not make mistakes. re-do! there can be two situations, one is (1, 2), (1, 4)... another is (1, 10), (2, 8)...)
792. Number of Matching Subsequences (This example illustrates how important to use pointer or reference to speedup!!! Look at the solution in the discussions! re-do.)
1138. Alphabet Board Path (should be easy. The special place is at (5, 0) to other locations.)
247. Strobogrammatic Number II (The trick is from center to outside do recursions. For each pair: 6,9 and 9,6 or (0,0, 1,1, 8,8). Outside cannot be 0,0. My solution is relatively slow....)
1428. Leftmost Column with at Least a One (For each row, do binary search to find the left most element with 1. A very good practise problem. Can re-do.)
1608. Special Array With X Elements Greater Than or Equal X (first sort and then keep on increasing x. if the found num is smaller than x, -1.)
1297. Maximum Number of Occurrences of a Substring (seems like a sliding window problem. For each substr, use a window to track the number of unique letters and keep on updating it when sliding. The tricky part is that we only need to check minSize, as the larger sizes contains the situations of smaller size ones!!! Also, the max freq of any substr. There may be duplicate or may be not.)
1535. Find the Winner of an Array Game (not hard. Go through the array. Keep track of first ele, if freq == k, return. otherwise, if found max_ele, return. otherwise, return max_ele.)
1282. Group the People Given the Group Size They Belong To (not very hard, but solution kind of slow. Greedy.)
16. 3Sum Closest (idea: first num from 0th element to n-1th element. for the other two elements, use two pointers to track the closest. similar to the 3sum problem.)
870. Advantage Shuffle (The trick is that first compare the largest between A and B, if found that A <= B, then choose the minimal element, otherwise, choose A. very good greedy practise. re-do!!!!)
670. Maximum Swap (The key is that find the max digit, and then swap it between the left most and right most max digit!!! re-do!!)
775. Global and Local Inversions (algorithm: from end to start, keep track of the minimum (keep one element apart from cur), and if cur > minimum, return false.)
1058. Minimize Rounding Error to Meet Target (greedy. floor all the prices and compare with target. The difference is filled by those closeset to original prices.)
452. Minimum Number of Arrows to Burst Balloons (Be careful. Do not make mistakes. Made so many mistakes. re-do!)
1005. Maximize Sum Of Array After K Negations (Greedy. The key is that convert from smallest negative value, and keep track of the minimal positive value.)
874. Walking Robot Simulation (Simulation. Can use customized unordered_set.)
962. Maximum Width Ramp (See the other solutions!!! Re-do later!!!)
1564. Put Boxes Into the Warehouse I (sort the box and get the min_value of warehouse from left to right, and then use two pointers to get the solution.)
1524. Number of Sub-arrays With Odd Sum (be careful. it is pre_sum - another pre_sum. also, notice the other solution in the discussion. re-do.)
223. Rectangle Area (Just be careful. The areas not considering the over_lapping may be beyond INT_MAX)
368. Largest Divisible Subset (a dynamic programming problem. O(n^2))
681. Next Closest Time (Permutate all the possibilities. Note that for all the digits which are the same, just return themselves. It is a special case and was not well stated in the problem description.)
445. Add Two Numbers II (list problem. may study the solution in discussions)
469. Convex Polygon (well, be careful of the last two points. Have to extend as it is circular. Also, cross product can be 0. The key is >=, or <=. If both, wrong.)
1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers (use hash table to solve. see the discussions for potential faster solutions.)
2. Add Two Numbers (just be careful. when >= 10, minus; if not, do not need to.)
86. Partition List (two pointers and then connect them. Just be careful!)
339. Nested List Weight Sum (DFS. A good practise.)
1315. Sum of Nodes with Even-Valued Grandparent (Tree. two layers. re-do.)
1302. Deepest Leaves Sum (Tree. pre, in, or post do not matter. The key is to track the deepest layer.)
1490. Clone N-ary Tree (deep clone N-ary tree.)
366. Find Leaves of Binary Tree (Tree problem. A very good problem. The key is to track the depth and assign to the vector. If the depth is beyond the vector size, resize the vector.)
1448. Count Good Nodes in Binary Tree (Tree problem. Just keep track of the max element along the way!)
6. ZigZag Conversion (A high frequency problem. Find the rule and apply it. Each row is a string. Finally add the strings together.)
987. Vertical Order Traversal of a Binary Tree (High frequency. The requirement is not clear. Actually for the same x, the layer close to root goes first, and the if same layer, the value smaller goes first.)
103. Binary Tree Zigzag Level Order Traversal (BFS and adjust sequence.)
1209. Remove All Adjacent Duplicates in String II (High freq. Use stack can solve it. At beginning, push {'\0', 0})
946. Validate Stack Sequences (very good practise. Two pointers can solve this!)
163. Missing Ranges (Two main conditions. Either nums.size() == 0 or nums.size() != 0.)
1557. Minimum Number of Vertices to Reach All Nodes (The idea is that if there is incoming edge, the nodal flag will increase. After all, find all the nodes which do not have incoming edges. The idea is obtained from the problem '210. Course Schedule II' second solution.)
785. Is Graph Bipartite? (A very good practise. I used DFS. Mark one as 1, then next is 2. If there is conflict. Return false.)
74. Search a 2D Matrix (Be careful. The bound measures the elements corresponds to the target. Binary search.)
652. Find Duplicate Subtrees (A Google problem. post order solves the problem. The algorithm is that each node is represented by a sequence from post order.)
841. Keys and Rooms (Method 1: DFS. Start from room 0 and if not all rooms are entered, false.)
323. Number of Connected Components in an Undirected Graph (union find should solve this problem)
735. Asteroid Collision (Use stack to solve it.)
990. Satisfiability of Equality Equations (Just use union find to solve it. Seems worked pretty well.)
743. Network Delay Time (Dijkstra's algorithm can solve it.)
1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree (My strategy: pre-order original and cloned at the same time.)
1664. Ways to Make a Fair Array (DP. The trick is to record the pre_sum and odd and even respectively. And after some index, they will flip. Go through the indexes to check whether the sum are equal.)
1328. Break a Palindrome (Strategy: if only one letter, return ""; if found first non 'a' letter, replace it with 'a'. if not found non 'a' letter, replace the last with 'b'.)
96. Unique Binary Search Trees (The strategy: iterate the root number, and the left and right are sub trees. If one of the sub tree is 0, just add the other. If both are non-zero, add the combinations of the two sub-trees.)
187. Repeated DNA Sequences (Should be easy...)
228. Summary Ranges (Just go through the elements to find continuous range.)
993. Cousins in Binary Tree (Just pre-order DFS with parent val as input and find x, y can solve the problem.)
1672. Richest Customer Wealth (Easy. Python to do.)
150. Evaluate Reverse Polish Notation (Python: Divide two integers always do floor division, fixed by using int(float(a) / b); Java: equals compares the content and == compares the reference)
542. 01 Matrix (A good BFS problem. Once the method is determined, it is easy to solve. Note that there are some other variations of problems which require other methods!)
658. Find K Closest Elements (Two pointers solve the problem.)
165. Compare Version Numbers (A string problem. Give a pointer of each string solved the problem. Just be careful.)
1685. Sum of Absolute Differences in a Sorted Array (It is first based on the sum corresponding to the first element, and then it goes through the array and update each element. The time complexity is O(n).)
130. Surrounded Regions (The boundary 'O' and their connections can be easily identified.)
935. Knight Dialer (DP. Just be careful.)
1684. Count the Number of Consistent Strings (Easy)

*Problem 392: one string is a substring of another, re-visit.

*Problems 503, 1475 in Leetcode:

Similarity: find the next element which is greater or smaller than the current one. The complexity in space and time can be O(n). 

*convert string to lowercase (can use transform as shown below or write one myself)
Example:
std::string data = "Abc";
std::transform(data.begin(), data.end(), data.begin(), [](unsigned char c){ return std::tolower(c); });
    
*string's length: .length()

*10 ways to convert a char to string in C++:

https://www.techiedelight.com/convert-char-to-string-cpp/

*std::vector does not have push_front

*<cstdlib> (stdlib.h)
http://www.cplusplus.com/reference/cstdlib/

*random number generator:
#include <time.h>  
srand(time(NULL)); 
int j = rand() % max_number; //generate a number between (0, max_number - 1)  

*reverse loop through an array:
wrong: for (size_t i = a_vector.size(); i >= 0; i--)
correct: for (int i = a_vector.size(); i >= 0; i--)

*char and integer correspondance:
'A' <-> 65
'a' <-> 97

*for single digit number char, e.g. '9' - '0' can be 9!

*the middle element:
Given an array with size n. If n is odd, n / 2 will give the exact middle element and if n is even, n / 2 will give the right one of the middle two elements.

*string find_first_of, find_last_of:
while (i < j) {
    i = s.find_first_of("aeiouAEIOU", i);
    j = s.find_last_of("aeiouAEIOU", j);
    if (i < j) {
        swap(s[i++], s[j--]);
    }
}

*std::swap

*comparison of values of size_t and int. The int number will be casted to size_t automatically.

//Example
#include <iostream>
using namespace std;
int main()
{
   size_t i = 1;
   int j = -1;
   
   std::cout << (i > j) << std::endl;
   std::cout << (j < i) << std::endl;
   std::cout << (i < j) << std::endl;
   std::cout << (j > i) << std::endl;
   
   return 0;
}
//Output
0
0
1
1

*count frequency of an element in a set(unordered_set): a_set.count(an_element)

*cctype library:

//notice that there are no '_' in the methods below!
#include <cctype>
isalpha()
isalnum()
isdigit()
tolower() 
toupper()

*stack: when stack.empty(), stack.pop() is erroneous

*substr: a_string(a_position, 0) is legal

*string: valid methods: push_back(), pop_back, a_string.back()

*append: for C++, only string library have 'append' method.

*Problem 225: implement stack using queues

Note: we can either use one or two queues to achieve this.

*stringstream example:

Example:
process string separated by space:

        stringstream ss(sentence);
        
        size_t count = 0;
        
        string token;
        
        while (ss >> token)
        {
            
            if (token.substr(0, searchWord.size()) == searchWord) return count + 1;
            
            count++;
        }
        
Example:
process string separated by comma:

#include <iostream>
#include <sstream>

int main()
{
    std::string input = "abc, def,  ghi";
    std::istringstream ss(input);
    std::string token;
    
    while(std::getline(ss, token, ',')) {
        std::cout << token << '\n';
    }

    return 0;
}

output:
abc                                                                                                                                                                                  
 def                                                                                                                                                                                 
  ghi
  
*count (can be used for string, vector, etc)

#include <iostream>
#include <algorithm>
using namespace std; 
  
int main() 
{ 
    string str = "geeksforgeeks"; 
  
    cout << "Number of times 'e' appears : " 
         << count(str.begin(), str.end(), 'e'); 
  
    return 0; 
} 

*string: string::npos equals to -1

*set (multiset) erase: 

erase(a_set.begin()): only erases the iterater!
erase(*a_set.begin()): erase all the elements with the value!

*std::upper_bound: returns an iterator pointing to the first element in the range [first,last) which compares greater than val.

*std::lower_bound: returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.

*first and last element: .front() and .back() for std::vector, std::list, std::queue, std::string

*distance between iterations: std::distance

*1051. Height Checker:
the multiset sort can be replaced by a vector or unordered_map

*1E3 and 10E3 are different and 1E3 is default double 

*-3 % 2 equals to -1 not 1!

*std::equal_range for a sorted sequence
http://www.cplusplus.com/reference/algorithm/equal_range/

*emplace for unordered_map
Example:
        std::unordered_map <int, int> map_val_rank;
        
        for (const auto& item : arr_copy)
        {
            map_val_rank.emplace(item, map_val_rank.size() + 1);
        }
        
*binary search prototype:
441. Arranging Coins
    long left = 0, right = n;
    long k, curr;
    while (left <= right)
    {
        k = left + (right - left) / 2;

        curr = k * (k + 1) / 2;

        if (curr == n) return k;

        if (n < curr) right = k - 1;
        else left = k + 1;

        std::cout << "left, right: " << left << ", " << right << std::endl;
    }
    
*a square number is 1+3+5+7+...

*-1 is also considered to be true!

Example:
#include <iostream>

using namespace std;

int main()
{
   if (-1)
   {
       std::cout << "Test a1\n";
   }
   
   return 0;
}

Output:
Test a1

*divide by 0:
cout << 5 / 0 << endl; //error
cout << 1.0 * 5 / 0 << endl; //ok

*floor and ceil

*numeric_limits:
Example:
#include <iostream>
#include <limits>
int main()
{
    double max = std::numeric_limits<double>::max();
    double inf = std::numeric_limits<double>::infinity();
 
    if(inf > max)
        std::cout << inf << " is greater than " << max << '\n';
}
Example:
std::numeric_limits <int>::infinity(); //returns 0!!!!! seems only working for floating numbers

*'-' cannot be used in variable name. 
Example:
string letter-log; //error

*string insert format:
Example:
a_string.insert(position, count, a_char)

string& insert (size_t pos, const string& str);
string& insert (size_t pos, const string& str, size_t subpos, size_t sublen);
string& insert (size_t pos, const char* s);
string& insert (size_t pos, const char* s, size_t n);
string& insert (size_t pos, size_t n, char c);
void insert (iterator p, size_t n, char c);
iterator insert (iterator p, char c);
template <class InputIterator>
void insert (iterator p, InputIterator first, InputIterator last);

*for an array of size n, if n % 2 == 1, the middle element index is n / 2, and if n % 2 == 0, the middle right element index is n / 2 (assume element starts from 0).

*multimap: overloading [], wrong!
Example:
a_map[a] = b; //wrong!

*find(vector_of_vector.begin(), vector_of_vector.end(), {a, b}) //wrong expression, cannot use {a, b}

*sort(a.begin(), a.end()) //note that for sort, the end position is the real find position + 1

*gcd, lcm since C++17

*std::cout << -3 % (-2) << std::endl; //result -1, the quotient is closer to 0

*note that for iterating through the vector, sometimes forgot to update the operations of the last element:
Example:
        int pre_diff = A[1] - A[0];
        int count = 1;
        for (int i = 0; i < A.size() - 1; ++i)
        {
            int diff = A[i + 1] - A[i];
            
            if (diff == pre_diff && i != A.size() - 2)
            {
                count++;
            }
            else if (diff == pre_diff && i == A.size() - 2)
            {
                count++;
                consecutive.push_back(count);
            }
            else if (diff != pre_diff)
            {
                if (count >= 3) consecutive.push_back(count);
                
                pre_diff = diff;
                count = 2;
            }
        }

*int64_t, int32_t

*sliding window: note the less or equal to, and note the overflow (problem 1343)

*__builtin_popcount(int) function is used to count the number of one’s(set bits) in an integer.

*std::sort(a_string.begin(), a_string.end()); //it works for C++ to sort a string.

*numeric_limits:

Example:

#include <limits>
#include <iostream>
 
int main() 
{
    std::cout << "type\tlowest()\tmin()\t\tmax()\n\n";
 
    std::cout << "uchar\t"
              << +std::numeric_limits<unsigned char>::lowest() << '\t' << '\t'
              << +std::numeric_limits<unsigned char>::min() << '\t' << '\t'
              << +std::numeric_limits<unsigned char>::max() << '\n';
    std::cout << "int\t"
              << std::numeric_limits<int>::lowest() << '\t'
              << std::numeric_limits<int>::min() << '\t'
              << std::numeric_limits<int>::max() << '\n';
    std::cout << "float\t"
              << std::numeric_limits<float>::lowest() << '\t'
              << std::numeric_limits<float>::min() << '\t'
              << std::numeric_limits<float>::max() << '\n';
    std::cout << "double\t"
              << std::numeric_limits<double>::lowest() << '\t'
              << std::numeric_limits<double>::min() << '\t'
              << std::numeric_limits<double>::max() << '\n';
}

type	lowest()	min()		max()
uchar	0		0		255
int	-2147483648	-2147483648	2147483647
float	-3.40282e+38	1.17549e-38	3.40282e+38
double	-1.79769e+308	2.22507e-308	1.79769e+308

*std::string::erase
sequence (1)	
string& erase (size_t pos = 0, size_t len = npos);
character (2)	
iterator erase (iterator p);
range (3)	
iterator erase (iterator first, iterator last);

*it = lower_bound(it, A.end(), cur); //A is a sorted vector of string, and cur is a string. 
You can use lower bound to find the first element in the vector which matches cur. The complexity is log(N).

*erase-remove idiom
https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom
https://stackoverflow.com/questions/3385229/c-erase-vector-element-by-value-rather-than-by-position
#include <algorithm>
...
vec.erase(std::remove(vec.begin(), vec.end(), 8), vec.end());
This combination is also known as the erase-remove idiom.

*std::accumulate with lambda function
Example:
return accumulate(begin(res), end(res), 0, [&](int s, int i) { return s + n[i] * vec.n[i]; });

Example:
#include <vector>
#include <algorithm>
#include <iostream>
#include <numeric>
using namespace std;
std::vector<int> v = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

int main()
{
    auto lambda = [&](double a, double b){return a + b / v.size(); };
    std::cout << std::accumulate(v.begin(), v.end(), 0.0, lambda) << std::endl;
}

*set_intersection
Example:
vector<int> res;
set_intersection(begin(v), end(v), begin(vec.v), end(vec.v), back_inserter(res));

*set_intersection of two vectors. Two pointers:
1570. Dot Product of Two Sparse Vectors
Example:
int dotProduct(SparseVector& vec, int res = 0) {
    for (int i = 0, j = 0; i < v.size() && j < vec.v.size(); ++i, ++j)
        if (v[i].first < vec.v[j].first)
            --j;
        else if (v[i].first > vec.v[j].first)
            --i;
        else
            res += v[i].second * vec.v[j].second;
    return res;
}

*out of range error for 'for loop':
Example:
for (int i = 0; i <= (int) (S.length() - K); ++i) //if 'S.length() - K' is not converted to int, error is generated!!!

*nth_element:
Example:
int n = nums.size();
auto it = nums.begin() + n/2;
nth_element(nums.begin(), it, nums.end());
int median = *it;

*sort by function example:
1333. Filter Restaurants by Vegan-Friendly, Price and Distance
Example:
    static bool cmp(const vector<int>& v1, const vector<int>& v2) {
        return v1[1] == v2[1] ? v1[0] > v2[0] : v1[1] > v2[1];
    }
    
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        vector<vector<int>> res;
        
        for(int i = 0; i < restaurants.size(); i++) {
            if (!restaurants[i][2] && veganFriendly) continue;//be careful
            if(restaurants[i][3] > maxPrice) continue;
            if(restaurants[i][4] > maxDistance) continue;
            res.push_back(restaurants[i]);
        }
        
        sort(res.begin(), res.end(), cmp);
        
        vector<int> ids;
        for(int i = 0; i < res.size(); i++) ids.push_back(res[i][0]);
        return ids;
    }
    
*accumulate
Example
std::accumulate(a_vec.begin(), a_vec.end(), 0); //if a_vec is of double, it will be casted into int!!!
    
*includes
Example:
found = std::includes(comp2.begin(), comp2.end(), comp1.begin(), comp1.end()); //note that comp1 and comp2 need to be sorted

*this->small = small //note that in a class, 'this' is used so that identical names can be used.

*erase while iterating
example:
for(it2 = uc.begin(); it2 != uc.end();)
{
   ...   
   if(...)
   {
      it2 = uc.erase(it2); //the key!
   }
   else
   {
      ++it2;
   }
   ...
}

*practice: convert a string into a string of sequential unique characters, e.g.: convert "aaaabbbbccdde" into 'abcde'. The tricky part is the first and last position!!!

*practise: identify intervals of continuous 1s. 1513. Number of Substrings With Only 1s

*priority_queue:
https://en.cppreference.com/w/cpp/container/priority_queue
A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.

*multi-dimensional array, memset
Example:
int dp[m + 1][n + 1][4];
memset(dp, 0, sizeof dp);
std::cout << "there are: " << sizeof dp / sizeof(int) << " elements." << std::endl;

*long int:
Example
1L

*unordered_set with pair!!!:
Use an operator!
Example:
#include <iostream>
#include <unordered_set>

using namespace std;

struct PositionHash
{
    size_t operator()(const pair<int, int> &val) const
    {
        return val.first ^ val.second;
    }
};

int main()
{
   unordered_set<pair<int, int>, PositionHash> obs;
   
   obs.insert({1,2});
   obs.insert({1000000000, 1000000000});
   
   return 0;
}

*unordered_map with std::pair 
Example:
https://www.geeksforgeeks.org/how-to-create-an-unordered_map-of-pairs-in-c/
// CPP program to demonstrate implementation of 
// unordered_map for a pair. 
#include <bits/stdc++.h> 
using namespace std; 
  
// A hash function used to hash a pair of any kind 
struct hash_pair { 
    template <class T1, class T2> 
    size_t operator()(const pair<T1, T2>& p) const
    { 
        auto hash1 = hash<T1>{}(p.first); 
        auto hash2 = hash<T2>{}(p.second); 
        return hash1 ^ hash2; 
    } 
}; 
  
int main() 
{ 
    // Sending the hash function as a third argument 
    unordered_map<pair<int, int>, bool, hash_pair> um; 
  
    // Creating some pairs to be used as keys 
    pair<int, int> p1(1000, 2000); 
    pair<int, int> p2(2000, 3000);  
    pair<int, int> p3(2005, 3005);  
      
    // Inserting values in the unordered_map. 
    um[p1] = true; 
    um[p2] = false; 
    um[p3] = true; 
  
    cout << "Contents of the unordered_map : \n"; 
    for (auto p : um) 
        cout << "[" << (p.first).first << ", " 
             << (p.first).second << "] ==> "
             << p.second << "\n"; 
  
    return 0; 
}

*string concatenation time complexity in C++:
https://stackoverflow.com/questions/15400508/string-concatenation-complexity-in-c-and-java

*priority_queue (reverse)
Example:
https://en.cppreference.com/w/cpp/container/priority_queue
std::priority_queue<int, std::vector<int>, std::greater<int> > q2;

*array initialization
https://stackoverflow.com/questions/201101/how-to-initialize-all-members-of-an-array-to-the-same-value

Example:
Don't overlook the obvious solution, though:

int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
Elements with missing values will be initialized to 0:

int myArray[10] = { 1, 2 }; // initialize to 1,2,0,0,0...
So this will initialize all elements to 0:

int myArray[10] = { 0 }; // all elements 0
In C++, an empty initialization list will also initialize every element to 0. This is not allowed with C:

int myArray[10] = {}; // all elements 0 in C++
Remember that objects with static storage duration will initialize to 0 if no initializer is specified:

static int myArray[10]; // all elements 0
And that "0" doesn't necessarily mean "all-bits-zero", so using the above is better and more portable than memset(). (Floating point values will be initialized to +0, pointers to null value, etc.)

*insert for map and unordered_map!!!!!!!!!!
Caveat: if the key is already there, the insertion will not be conducted!!!
Example:
#include <iostream>
#include <vector>
#include <unordered_map>
#include <map>

using namespace std;

int main()
{
   std::vector < std::map <int, int> > test(5);
   
   test[0].insert({0, 7});
   test[0].insert({0, 2});
   test[0].insert({0, 3});
   test[0].insert({0, 8});
   
   //test[0][0] = -2;
   
   std::cout << test[0].size() << ", " << test[0][0] << std::endl;
   
   for (auto item : test)
   {
       for (auto item2 : item)
       {
           cout << item2.first << ",  " << item2.second << std::endl;
       }
   }

   return 0;
}

Output:
1, 7
0,  7

*std::map, std::unordered_map, std::set, std::unordered_set can have operators ++, --!!!!!! 
Example:
iter++;
iter--;
However, iter = iter + 1 is wrong!!!!!!

*count on a char in a string (notice the single quote!!!)
std::count(input.begin() + loc, input.begin() + loc_next, '\t');

*bitset
https://www.geeksforgeeks.org/c-bitset-and-its-application/
bitset index is reversed!

*binary representation of a number
Example:
393. UTF-8 Validation
class Solution {
public:
    bool validUtf8(vector<int>& data) {
        
        int n = data.size();
        vector < bool > flags(n + 1);
        
        flags[0] = true;
        
        for (int i = 1; i <= n; ++i)
        {
            if (data[i - 1] >> 7 == 0b0 && flags[i - 1] == true)
            {
                flags[i] = true;
            }
            else if (i >= 2 &&                      
                data[i - 1] >> 6 == 0b10 && data[i - 2] >> 5 == 0b110 &&
                flags[i - 2] == true
               )
            {
                flags[i] = true;
            }
            else if (i >= 3 && 
                data[i - 1] >> 6 == 0b10 &&
                data[i - 2] >> 6 == 0b10 &&
                data[i - 3] >> 4 == 0b1110 &&
                flags[i - 3] == true
               )
            {
                flags[i] = true;
            }
            else if (i >= 4 &&                      
                data[i - 1] >> 6 == 0b10 &&
                data[i - 2] >> 6 == 0b10 &&     
                data[i - 3] >> 6 == 0b10 &&
                data[i - 4] >> 3 == 0b11110 &&
                flags[i - 4] == true
               )
            {
                flags[i] = true;
            }      
        }
        
        return flags[n];
    }
};

Another example:
https://leetcode.com/problems/campus-bikes-ii/submissions/
class Solution {
    
    vector <vector <int>> dp;
    
    int Big = INT_MAX;
    
    //usually, it is template <class T>
    template<size_t S>
    int helper(vector<vector<int>>& workers, vector<vector<int>>& bikes, int index, bitset <S>& flags)
    {
        if (index == N) return 0;
        
        int min_sum = Big;
        
        for (int j = 0; j < M; ++j)
        {
            if (flags[j] == 0)
            {
                flags[j] = 1;

                int cur_sum = abs(workers[index][0] - bikes[j][0]) + abs(workers[index][1] - bikes[j][1]);
                
                int temp = flags.to_ulong();
                
                if (dp[index][temp] == Big)
                {
                    int sum = helper(workers, bikes, index + 1, flags);
                    
                    dp[index][temp] = sum;
                    
                    min_sum = min(min_sum, cur_sum + sum);
                }
                else
                {
                    min_sum = min(min_sum, cur_sum + dp[index][temp]);
                }

                flags[j] = 0;
            }
        }
        
        return min_sum;
    }
    
    int N, M;
    
public:
    int assignBikes(vector<vector<int>>& workers, vector<vector<int>>& bikes) {
        
        //This is a great question! Combination of backtracking and DP. Note that for DP, the state can be (1 << M)!!! Can re-do!!!
        
        N = workers.size();
        M = bikes.size();
        
        dp.resize(N + 1, vector <int>( 1 << M, Big));
        
        bitset <11> flags;
        
        int min_sum = helper(workers, bikes, 0, flags);
        
        return min_sum;
    }
};

*sizeof reference:
When applied to a reference or a reference type, the result is the size of the referenced type.
https://stackoverflow.com/questions/10446907/why-reference-size-is-always-4-bytes-c

*****Store return value of function in reference C++
https://stackoverflow.com/questions/2822243/store-return-value-of-function-in-reference-c
It is not allowed to bind the temporary to a non-const reference, but if you make your reference const you will extend the lifetime of the temporary to the reference, see this Danny Kalev post about it.
In short:
const A& mySecondObject = myFunction();

*find_last_not_of or find_last_of
find_last_not_of (const string& str, size_t pos = npos) const; //note that pos is the last position to be considered of!!!!!!

*inplace_merge
http://www.cplusplus.com/reference/algorithm/inplace_merge/

*using smart pointers to initialize an array:
Example:
unique_ptr <int[]> array; //note the use of brackets!!!
array = unique_ptr <int[]>(new int[k]);

*lower_bound on vector of vector!!!
Example:
auto iter = lower_bound(a.begin(), a.end(), 4, [&](vector <int>& a1, int value){ return a1[0] < value;}); //without the lambda function it will be erroneous!!!
