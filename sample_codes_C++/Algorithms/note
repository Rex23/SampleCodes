*Remembered problems:

1. The rainfall volumes between the mountains

2. randomly shuffle an array of numbers

3. a string problem?

4. rvalue reference

5. hash table

6. virtual table?

7. HackerRank

8. re-visit problems: 
1004. (sliding window) 
1237.
1446. Consecutive Characters
303. Range Sum Query - Immutable
696. Count Binary Substrings
1071. Greatest Common Divisor of Strings
1089. Duplicate Zeros (there is a better solution)

*Problem 392: one string is a substring of another, re-visit.

*Problems 503, 1475 in Leetcode:

Similarity: find the next element which is greater or smaller than the current one. The complexity in space and time can be O(n). 

*string's length: .length()

*10 ways to convert a char to string in C++:

https://www.techiedelight.com/convert-char-to-string-cpp/

*std::vector does not have push_front

*<cstdlib> (stdlib.h)
http://www.cplusplus.com/reference/cstdlib/

*random number generator:
#include <time.h>  
srand(time(NULL)); 
int j = rand() % max_number; //generate a number between (0, max_number - 1)  

*reverse loop through an array:
wrong: for (size_t i = a_vector.size(); i >= 0; i--)
correct: for (int i = a_vector.size(); i >= 0; i--)

*char and integer correspondance:
'A' <-> 65
'a' <-> 97

*the middle element:
Given an array with size n. If n is odd, n / 2 will give the exact middle element and if n is even, n / 2 will give the right one of the middle two elements.

*string find_first_of, find_last_of:
while (i < j) {
    i = s.find_first_of("aeiouAEIOU", i);
    j = s.find_last_of("aeiouAEIOU", j);
    if (i < j) {
        swap(s[i++], s[j--]);
    }
}

*std::swap

*comparison of values of size_t and int. The int number will be casted to size_t automatically.

//Example
#include <iostream>
using namespace std;
int main()
{
   size_t i = 1;
   int j = -1;
   
   std::cout << (i > j) << std::endl;
   std::cout << (j < i) << std::endl;
   std::cout << (i < j) << std::endl;
   std::cout << (j > i) << std::endl;
   
   return 0;
}
//Output
0
0
1
1

*count frequency of an element in a set(unordered_set): a_set.count(an_element)

*cctype library:

#include <cctype>
isalpha()
isalnum()
isdigit()
tolower()
toupper()

*stack: when stack.empty(), stack.pop() is erroneous

*substr: a_string(a_position, 0) is legal

*string: valid methods: push_back(), pop_back, a_string.back()

*append: for C++, only string library have 'append' method.

*Problem 225: implement stack using queues

Note: we can either use one or two queues to achieve this.

*stringstream example:

Example:
process string separated by space:

        stringstream ss(sentence);
        
        size_t count = 0;
        
        string token;
        
        while (ss >> token)
        {
            
            if (token.substr(0, searchWord.size()) == searchWord) return count + 1;
            
            count++;
        }
        
Example:
process string separated by comma:

#include <iostream>
#include <sstream>

int main()
{
    std::string input = "abc, def,  ghi";
    std::istringstream ss(input);
    std::string token;
    
    while(std::getline(ss, token, ',')) {
        std::cout << token << '\n';
    }

    return 0;
}

output:
abc                                                                                                                                                                                  
 def                                                                                                                                                                                 
  ghi
  
*count (can be used for string, vector, etc)

#include <iostream>
#include <algorithm>
using namespace std; 
  
int main() 
{ 
    string str = "geeksforgeeks"; 
  
    cout << "Number of times 'e' appears : " 
         << count(str.begin(), str.end(), 'e'); 
  
    return 0; 
} 

*string: string::npos equals to -1

*set (multiset) erase: 

erase(a_set.begin()): only erases the iterater!
erase(*a_set.begin()): erase all the elements with the value!

*std::upper_bound: returns an iterator pointing to the first element in the range [first,last) which compares greater than val.

*std::lower_bound: returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.

*first and last element: .front() and .back() for std::vector, std::list, std::queue, std::string

*distance between iterations: std::distance

*1051. Height Checker:
the multiset sort can be replaced by a vector or unordered_map

*1E3 and 10E3 are different and 1E3 is default double 

*-3 % 2 equals to -1 not 1!

*std::equal_range for a sorted sequence
http://www.cplusplus.com/reference/algorithm/equal_range/

*emplace for unordered_map
Example:
        std::unordered_map <int, int> map_val_rank;
        
        for (const auto& item : arr_copy)
        {
            map_val_rank.emplace(item, map_val_rank.size() + 1);
        }


