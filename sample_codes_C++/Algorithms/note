*Remembered problems:

1. The rainfall volumes between the mountains

2. randomly shuffle an array of numbers

3. a string problem?

4. rvalue reference

5. hash table

6. virtual table?

7. HackerRank

8. re-visit problems: 
1004. (sliding window) 
1237.
1446. Consecutive Characters
303. Range Sum Query - Immutable
696. Count Binary Substrings
1071. Greatest Common Divisor of Strings
1089. Duplicate Zeros (there is a better solution)
441. Arranging Coins
1539. Kth Missing Positive Number (next time resolve it using binary search)
1275. Find Winner on a Tic Tac Toe Game (good practice to consider the corner cases)
989. Add to Array-Form of Integer (notice the given solution method in Java)
937. Reorder Data in Log Files (a hard problem!)
507. Perfect Number (re-visit!)
168. Excel Sheet Column Title (interesting)
453. Minimum Moves to Equal Array Elements
189. Rotate Array (must try the O(1) extra space method!)
532. K-diff Pairs in an Array (notice that k can be <0, == 0, and > 0, and same numbers only count once)
414. Third Maximum Number (consider using one loop)
535. Encode and Decode TinyURL (what is tinyURL?)
953. Verifying an Alien Dictionary (compare adjacent string, re-do)
447. Number of Boomerangs (notice that for each point, generate a hash map)
299. Bulls and Cows (re-do, think about some faster method)
1556. Thousand Separator (make sure pass one time. 1. a_string.insert(position, count, char) 2. do not add '.' at position = 0)
1277. Count Square Submatrices with All Ones (dynamic programming, the 1D index one does not work because i, j are both updated!)
1433. Check If a String Can Break Another String (failed to work it out. Re-do!)
1104. Path In Zigzag Labelled Binary Tree (interesting, worth re-do)

*Problem 392: one string is a substring of another, re-visit.

*Problems 503, 1475 in Leetcode:

Similarity: find the next element which is greater or smaller than the current one. The complexity in space and time can be O(n). 

*string's length: .length()

*10 ways to convert a char to string in C++:

https://www.techiedelight.com/convert-char-to-string-cpp/

*std::vector does not have push_front

*<cstdlib> (stdlib.h)
http://www.cplusplus.com/reference/cstdlib/

*random number generator:
#include <time.h>  
srand(time(NULL)); 
int j = rand() % max_number; //generate a number between (0, max_number - 1)  

*reverse loop through an array:
wrong: for (size_t i = a_vector.size(); i >= 0; i--)
correct: for (int i = a_vector.size(); i >= 0; i--)

*char and integer correspondance:
'A' <-> 65
'a' <-> 97

*the middle element:
Given an array with size n. If n is odd, n / 2 will give the exact middle element and if n is even, n / 2 will give the right one of the middle two elements.

*string find_first_of, find_last_of:
while (i < j) {
    i = s.find_first_of("aeiouAEIOU", i);
    j = s.find_last_of("aeiouAEIOU", j);
    if (i < j) {
        swap(s[i++], s[j--]);
    }
}

*std::swap

*comparison of values of size_t and int. The int number will be casted to size_t automatically.

//Example
#include <iostream>
using namespace std;
int main()
{
   size_t i = 1;
   int j = -1;
   
   std::cout << (i > j) << std::endl;
   std::cout << (j < i) << std::endl;
   std::cout << (i < j) << std::endl;
   std::cout << (j > i) << std::endl;
   
   return 0;
}
//Output
0
0
1
1

*count frequency of an element in a set(unordered_set): a_set.count(an_element)

*cctype library:

//notice that there are no '_' in the methods below!
#include <cctype>
isalpha()
isalnum()
isdigit()
tolower() 
toupper()

*stack: when stack.empty(), stack.pop() is erroneous

*substr: a_string(a_position, 0) is legal

*string: valid methods: push_back(), pop_back, a_string.back()

*append: for C++, only string library have 'append' method.

*Problem 225: implement stack using queues

Note: we can either use one or two queues to achieve this.

*stringstream example:

Example:
process string separated by space:

        stringstream ss(sentence);
        
        size_t count = 0;
        
        string token;
        
        while (ss >> token)
        {
            
            if (token.substr(0, searchWord.size()) == searchWord) return count + 1;
            
            count++;
        }
        
Example:
process string separated by comma:

#include <iostream>
#include <sstream>

int main()
{
    std::string input = "abc, def,  ghi";
    std::istringstream ss(input);
    std::string token;
    
    while(std::getline(ss, token, ',')) {
        std::cout << token << '\n';
    }

    return 0;
}

output:
abc                                                                                                                                                                                  
 def                                                                                                                                                                                 
  ghi
  
*count (can be used for string, vector, etc)

#include <iostream>
#include <algorithm>
using namespace std; 
  
int main() 
{ 
    string str = "geeksforgeeks"; 
  
    cout << "Number of times 'e' appears : " 
         << count(str.begin(), str.end(), 'e'); 
  
    return 0; 
} 

*string: string::npos equals to -1

*set (multiset) erase: 

erase(a_set.begin()): only erases the iterater!
erase(*a_set.begin()): erase all the elements with the value!

*std::upper_bound: returns an iterator pointing to the first element in the range [first,last) which compares greater than val.

*std::lower_bound: returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.

*first and last element: .front() and .back() for std::vector, std::list, std::queue, std::string

*distance between iterations: std::distance

*1051. Height Checker:
the multiset sort can be replaced by a vector or unordered_map

*1E3 and 10E3 are different and 1E3 is default double 

*-3 % 2 equals to -1 not 1!

*std::equal_range for a sorted sequence
http://www.cplusplus.com/reference/algorithm/equal_range/

*emplace for unordered_map
Example:
        std::unordered_map <int, int> map_val_rank;
        
        for (const auto& item : arr_copy)
        {
            map_val_rank.emplace(item, map_val_rank.size() + 1);
        }
        
*binary search prototype:
441. Arranging Coins
    long left = 0, right = n;
    long k, curr;
    while (left <= right)
    {
        k = left + (right - left) / 2;

        curr = k * (k + 1) / 2;

        if (curr == n) return k;

        if (n < curr) right = k - 1;
        else left = k + 1;

        std::cout << "left, right: " << left << ", " << right << std::endl;
    }
    
*a square number is 1+3+5+7+...

*-1 is also considered to be true!

Example:
#include <iostream>

using namespace std;

int main()
{
   if (-1)
   {
       std::cout << "Test a1\n";
   }
   
   return 0;
}

Output:
Test a1

*divide by 0:
cout << 5 / 0 << endl; //error
cout << 1.0 * 5 / 0 << endl; //ok

*floor and ceil

*numeric_limits:
Example:
#include <iostream>
#include <limits>
int main()
{
    double max = std::numeric_limits<double>::max();
    double inf = std::numeric_limits<double>::infinity();
 
    if(inf > max)
        std::cout << inf << " is greater than " << max << '\n';
}
Example:
std::numeric_limits <int>::infinity(); //returns 0!!!!! seems only working for floating numbers

*'-' cannot be used in variable name. 
Example:
string letter-log; //error

*string insert format:
Example:
a_string.insert(position, count, a_char)

string& insert (size_t pos, const string& str);
string& insert (size_t pos, const string& str, size_t subpos, size_t sublen);
string& insert (size_t pos, const char* s);
string& insert (size_t pos, const char* s, size_t n);
string& insert (size_t pos, size_t n, char c);
void insert (iterator p, size_t n, char c);
iterator insert (iterator p, char c);
template <class InputIterator>
void insert (iterator p, InputIterator first, InputIterator last);

*for an array of size n, if n % 2 == 1, the middle element index is n / 2, and if n % 2 == 0, the middle right element index is n / 2 (assume element starts from 0).

*multimap: overloading [], wrong!
Example:
a_map[a] = b; //wrong!


