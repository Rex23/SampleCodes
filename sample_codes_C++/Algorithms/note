*Remembered problems:

1. The rainfall volumes between the mountains

2. randomly shuffle an array of numbers

3. a string problem?

4. rvalue reference

5. hash table

6. virtual table?

7. rvalue reference

7. Chicago trading interview problem

7. HackerRank

7. Two's complement?

7. What is a priority queue? 

7. What is a sliding window algorithm?

7. std::move forward? in C++

287 + 222 + 201 + 186 + 133 + 101 + 91 + 63 + 63 + 61 + 58 + 54 + 39 + 25 = 1584 (there are overlapping problems!)

8. very important re-visit problems:
767. Reorganize String (a very important problem! Did not figure out the solution at the beginning at all. Have to re-do!!! trick: from 1 to ..., and then from 0 to ... if a char is larger than (N + 1) / 2. no such solution...)
1062. Longest Repeating Substring (the current solution is pretty slow although can pass. Re-do! Reference the given solution.)
1023. Camelcase Matching (string and trie?????)
357. Count Numbers with Unique Digits (failed to solve. Two approaches. Re-do!!!!)
279. Perfect Squares (dynamic programming! do not make mistakes. re-do!)
729. My Calendar I (my lord. I had no clue at all! very hard to me! use set and lower_bound. re-do!!!!)
991. Broken Calculator (failed to work it out. very important. re-do!!!)
313. Super Ugly Number (had no clue at all!!!)
1072. Flip Columns For Maximum Number of Equal Rows (XOR. No clue at all. re-do!!!)
253. Meeting Rooms II (a very important problem. the idea is that first sort, and then keep track of the current first with the previously stored second interval by using upper_bound. time complexity?)
705. Design HashSet (it seems like I failed to design it. re-do!!!)
1248. Count Number of Nice Subarrays (failed to do. re-do!!!!!!)
1588. Sum of All Odd Length Subarrays (do not use brute force. re-do!!!!)
640. Solve the Equation (so complicated! it can be x, or 2x. made so many mistakes. re-do!)
523. Continuous Subarray Sum (very easy to make mistakes. Did not figure out first. re-do!!!!)
974. Subarray Sums Divisible by K (clasic! use hash map to solve! re-do! reference problem 523!)
11. Container With Most Water (Classic two pointer problem. The key is to move the shorter line every time because: If we try to move the pointer at the longer line inwards, we won't gain any increase in area, since it is limited by the shorter line. But moving the shorter line's pointer could turn out to be beneficial, as per the same argument, despite the reduction in the width.)
56. Merge Intervals (A classic interval problem! Be careful. Do not make mistakes! re-do!!! Note that the previous interval is evolving! Many companies tested this!)
1498. Number of Subsequences That Satisfy the Given Sum Condition (Classic! Classic! Classic! Classic two pointer problem! re-do!!!!!)
274. H-Index (visualize it. The key is to find the biggest i such that citations[i] > i. a key problem. re-do!!!)
57. Insert Interval (Try the solution in discussions. Three sections using while. Much clearer!)
560. Subarray Sum Equals K (classic, classic, classic! Have to re-do!!!)
1218. Longest Arithmetic Subsequence of Given Difference (classic!!! re-do!!! use hash table as dynamic programming!!!)
548. Split Array with Equal Sum (Did not figure out the solution. First find the middle one, and then loop through first half and see equal. and then loop through second half and see whether can find the same equal by using hash set. O(n^2))
1202. Smallest String With Swaps (a graph problem. do it later!!!!!!)
916. Word Subsets (note that for A to pass all B, it needs to have all distinct letter's max freq among B. I did not figure out the solution. re-do!!!!)
90. Subsets II (this problem is classic! re-do!!! here the subset is not necessarily continuous and sequential!!! And e.g. (1,4,4) and (4,1,4) are the same. what is a power set?????!!!!!)
259. 3Sum Smaller (my solution is slow. See the two pointer solution in the discussions! Classic!!! re-do!!!)
795. Number of Subarrays with Bounded Maximum (a dynamic programming (dp) problem. very hard!!!!!!! the tricky part is that when the previous is less than L, needs to add all of them.)
945. Minimum Increment to Make Array Unique (I did not figure out the solution. re-do!!!! the strategy is important. Without knowing the strategy, it cannot be solved. The strategy is that first sort, and then if A[i] <= A[i - 1], update A[i] to be A[i - 1] + 1.)
809. Expressive Words (problem can be solved by two pointers! a very good problem to consider corner conditions, i.e. beginning and end!!! re-do at some point!!!)
1046. Last Stone Weight (what a classic problem for priority_queue!!!!!! I did not figure out the solution. re-do!!!!!! Can also be done by using std::set? Probably yes.)
1518. Water Bottles (not hard, but very easy to make mistakes. re-do!)
313. Super Ugly Number (amazing but I did not figure out the solution at all!!!!! have to re-do!!!!!! classic!!!!!!!)
264. Ugly Number II (the same as problem 313. very important!)
1605. Find Valid Matrix Given Row and Column Sums (I did not figure out the solution. Greedy! re-do!!!!!!!!)
1513. Number of Substrings With Only 1s (change the string to intervals of 1 and add them up. The tricky part is that two relatively small numbers can multiply into a number which is overflow. Look at the given solution in the discussion. So elegant!!!!!!)
634. Find the Derangement of An Array (a dynamic programming problem!!! my goodness. For dynamic problem, the formula is the key! a classic problem. Did not figure out the solution. re-do!!!!)
983. Minimum Cost For Tickets (classic dynamic programming problem!!! Look at the usage of max(0, i) and min({a, b, c}), classic! Did not figure out the solution. Over thought about it. Re-do!!!)
1504. Count Submatrices With All Ones (failed again. very hard!!!!!!!!!!! do it later!!!!!!!!!!!!!!!!!)
881. Boats to Save People (Classic two pointers algorithm. the strategy is to pair heaviest and lightest. If not satisfy, only carry the heaviest... Use two pointers.)
424. Longest Repeating Character Replacement (Classic. A very very very important two pointer problem. Did not figure out the solution. re-do!!!!!!!)
487. Max Consecutive Ones II (similar to problem 424. Very important and classic!!!!!!!!!!!!!!!!)
325. Maximum Size Subarray Sum Equals k (made way tooooooo many mistakes!!!!!! re-do!!!!!!!!!!)
525. Contiguous Array (Classic hash table problem!!! worth re-do!!!!!!)
1419. Minimum Number of Frogs Croaking (the problem is classic!!!!!!! A very good interval problem and get the minimal re-usable intervals!!!!!! re-do!!!!!! find_first_not_of used here.)
484. Find Permutation (the trick is that first construct a vector, and then locally reverse based on how many 'D' there are and go forward.)
478. Generate Random Point in a Circle (simply re-do!)
1144. Decrease Elements To Make Array Zigzag (Do each case (even indexed is greater, odd indexed is greater) separately. In say the even case, you should decrease each even-indexed element until it is lower than its immediate neighbors. Note that it needs to be lower than its immediate neighbors!!!!!! I did not figure out the solution at all. zigzag. Re-do!!!!!!)
153. Find Minimum in Rotated Sorted Array (this seems like an important question as a lot of the companies tested this. However, I used my way to solve it. May re-visit later.)
120. Triangle (I can actually use zero extra space for this! Good job!)
1019. Next Greater Node In Linked List (The next greated element. Classic!!!!!! Did not figure out the solution. Use stack! Re-do!!!)
503. Next Greater Element II (Classic. Similar to problem 1019. Use stack to solve it. As it can be circular, pre stack the elements from end to start.)
755. Pour Water (Classic. note the key is to find the lowest to left and right respectively. Another key is that if found higher, it needs to stop.)
73. Set Matrix Zeroes (save the row and col info at first col and first row respectively. The (0, 0) can be confusing. Save first row and col info differently. re-do!)
328. Odd Even Linked List (made so many mistakes. The main issue is indexing. re-do!!!!)
430. Flatten a Multilevel Doubly Linked List (my goodness. made so many mistakes. have to re-do!!!!!!!!!!! 1. auto head_copy = head; (a new pointer is generated) 2. When the equal sign is there, the pointer is not modified and it points to a new content! 3. Needs to clean up the children.)
725. Split Linked List in Parts (Made so many mistakes! re-do!!!!!! The essense of the problem: Distribute the numbers with adjacent difference at most 1. The left is greater than the right. Just n / k and from left to right add 1. For each part, the next of the end element needs to point to nullptr.)
162. Find Peak Element (classic. binary search. re-do!!! The key is that the two ends are potentially the peak.)
79. 79. Word Search (Failed to solve (re-do!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!))
50. Pow(x, n) (interesting. re-do!!!!!!)
24. Swap Nodes in Pairs (a very very very import list question. Made so many mistakes. re-do!!!!!!)
1485. Clone Binary Tree With Random Pointer (only one hash map can solve it. re-do!!!!!!)
979. Distribute Coins in Binary Tree (classic. What should I say... Have to re-do!!!)
1457. Pseudo-Palindromic Paths in a Binary Tree (can use bit manipulation to solve it. re-do!!!!!!)
1110. Delete Nodes And Return Forest (A very good question. Google problem. The key is once found to be deleted node, push back its children. Do not forget to push back the root in the end. Also, to delete a node, the recursive method needs to have reference of pointer.)
1123. Lowest Common Ancestor of Deepest Leaves (Tree problem. A very important question!!!!!!!!! The key is that if both left and right contains the deepest leaf, it is the closest ancestor. Keep on updating until it finds the newest one which is the answer.)
5. Longest Palindromic Substring (A very important string question. Method 1: go through elements of s and calculate whether palindrome. Do method 2 later using dp!!!!!!)

*********************************************************************************
8. re-visit problems: 
1004. (sliding window) 
1237.
1446. Consecutive Characters
303. Range Sum Query - Immutable
696. Count Binary Substrings
1071. Greatest Common Divisor of Strings
1089. Duplicate Zeros (there is a better solution)
441. Arranging Coins
1539. Kth Missing Positive Number (next time resolve it using binary search)
1275. Find Winner on a Tic Tac Toe Game (good practice to consider the corner cases)
989. Add to Array-Form of Integer (notice the given solution method in Java)
937. Reorder Data in Log Files (a hard problem!)
507. Perfect Number (re-visit!)
168. Excel Sheet Column Title (interesting)
453. Minimum Moves to Equal Array Elements
189. Rotate Array (must try the O(1) extra space method!)
532. K-diff Pairs in an Array (notice that k can be <0, == 0, and > 0, and same numbers only count once)
414. Third Maximum Number (consider using one loop)
535. Encode and Decode TinyURL (what is tinyURL?)
953. Verifying an Alien Dictionary (compare adjacent string, re-do)
447. Number of Boomerangs (notice that for each point, generate a hash map)
299. Bulls and Cows (re-do, think about some faster method)
1556. Thousand Separator (make sure pass one time. 1. a_string.insert(position, count, char) 2. do not add '.' at position = 0)
1277. Count Square Submatrices with All Ones (dynamic programming, the 1D index one does not work because i, j are both updated! May look for better solutions in discussions?)
1433. Check If a String Can Break Another String (failed to work it out. Re-do!)
1104. Path In Zigzag Labelled Binary Tree (interesting, worth re-do)
1442. Count Triplets That Can Form Two Arrays of Equal XOR (definitely re-do, needs some derivations on XOR operations)
885. Spiral Matrix III (failed to work it out, re-do!)
338. Counting Bits (needs to re-visit sometime, remember the equation)
442. Find All Duplicates in an Array (re-do, two solutions, one is the one I figure out, the other is the solution in discussions)
969. Pancake Sorting (may worth re-do)
1338. Reduce Array Size to The Half (be careful, do not make mistakes)
877. Stone Game (failed to work out. Re-do! Dynamic programming dp(i, j), starts from dp(i,i) and then increase the i, j difference. Definitely worth re-doing)
1344. Angle Between Hands of a Clock (not hard, but be careful, do not mistake double to int, and each hour corresponds to 5 in the 60 circle)
1227. Airplane Seat Assignment Probability (dynamic programming problem. Although the solution is guessed. It is great if can derive later.)
1447. Simplified Fractions (from small to large number, if gcd(i,j) == 1 accumulate)
1017. Convert to Base -2 (remember the formula)
413. Arithmetic Slices (made too many mistakes, re-do)
665. Non-decreasing Array (definitely re-do, for i, first change (i - 1) if (i - 2) <= i, else change i == i - 1) 
1508. Range Sum of Sorted Subarray Sums (sliding window and do not make mistakes)
1362. Closest Divisors (be careful, do not make mistakes, priority_queue solution?)
553. Optimal Division (maybe understand the problem better?)
1233. Remove Sub-Folders from the Filesystem (I did not figure out this solution. Have to re-do.)
1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold (sliding window, note less or equal to, and note the overflow, can also be solved by presum)
1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (greedy approach; did not figure out the solution myself)
1375. Bulb Switcher III (two steps; keep track of the right most bulb; did not figure out the solution myself)
1566. Detect Pattern of Length M Repeated K or More Times (there is another O(n) solution)
1437. Check If All 1's Are at Least Length K Places Away (be careful not to make mistakes, may worth re-do)
1493. Longest Subarray of 1's After Deleting One Element (I have no idea about the solution!!! Resolve it later with the other sliding window problems!!!)
290. Word Pattern (made so many mistakes! Read solution)
762. Prime Number of Set Bits in Binary Representation (note the __builtin_popcount solution and the bitset<32>(i).count() solution)
781. Rabbits in Forest (note the use of map, key: total rabbits of same color, value: accumulated rabbits. Note that do not forget to add all the remaining map keys)
858. Mirror Reflection (I did not figure out this solution. This is done by mirroring the blocks. It needs some drawings and summary.)
963. Minimum Area Rectangle II (in my opinion, a hard problem. Have to remember to use centroid and diagonal length.)
1011. Capacity To Ship Packages Within D Days (a phenominon binary search problem. According to the discussions, similar problems are 

1482. Minimum Number of Days to Make m Bouquets
1283. Find the Smallest Divisor Given a Threshold
1231. Divide Chocolate
1011. Capacity To Ship Packages In N Days
875. Koko Eating Bananas
774. Minimize Max Distance to Gas Station
410. Split Array Largest Sum
)

1031. Maximum Sum of Two Non-Overlapping Subarrays (This question is worth re-do. Two pre_sum. Do not make mistakes.)
1267. Count Servers that Communicate (not hard but do not make mistakes, j and a_vector[i][j] are different! The solution in the discussions is great.)
48. Rotate Image (I did not figure out the solution. First top and bottom rows reverse. Second diagonal swap.)
1471. The k Strongest Values in an Array (Lession learned: 1. Read the problem statement carefully. The returned values are the arr elements. 2. Do not forget corner cases. In this case, arr.size() == 1.)
216. Combination Sum III (Failed to solve. Backtracking problem!!!!! Using my methods keep passing time limit. The key is to keep increasing the next element.
This is an important problem. Should try doing later several times.)
39. Combination Sum (worth re-do. Similar to problem 216.)
22. Generate Parentheses (worth re-do. Another backtracking problem.)
1111. Maximum Nesting Depth of Two Valid Parentheses Strings (Did not understand the problem. Re-do! The trick is to split even as much as possible. The odd and even parentheses are separated into A and B respectively.)
287. Find the Duplicate Number (my unique way of resolving it)
1249. Minimum Remove to Make Valid Parentheses (stack is used. sometimes slow down the writing can avoid a lot of logic and typo errors.)
856. Score of Parentheses (failed to solve. do not make mistakes. the trick: count number of '(', if found '(' and next is ')', add the score; if only found ')', decrease the number of '('.re-solve later!!!!!!)
1035. Uncrossed Lines (dynamic programming, I did not figure out the solution. Re-do!!!)
256. Paint House (dynamic programming, I did not figure out the solution. Re-do. The DP can be 2D!)
276. Paint Fence (dynamic programming, I did not figure out the solution. Re-do. Needs some derivations.)
1043. Partition Array for Maximum Sum (dynamic programming. I did not figure out the solution. This is a hard problem! The key is that for any element, goes back from 1 to k, and see which one is the largest. re-do!!!)
758. Bold Words in String (made so many mistakes!! re-do!!! a_string.find(another_string, start_position)!!! inserting something into a string is awlays a pain!)
1286. Iterator for Combination (very interesting problem for backtracking. Figured out myself. Do not forget return. Worth re-do.)
1198. Find Smallest Common Element in All Rows (Of lower priority to re-do. Use set_intersection to solve the problem. the container types need to be the same)
1056. Confusing Number (Of lower priority to re-do. Note that the rotation is not based on each digit but based on the entire number.)
370. Range Addition (range addition time complexity can be O(m + n). I did not work it out myself. A Google problem. Definitely worth re-do!!)
1151. Minimum Swaps to Group All 1's Together (classic sliding window problem! worth re-do! Do not make mistakes)
565. Array Nesting (I did not figure out the solution. The trick is that once the number is involed, it is no longer involved. Definitely do it again.)
311. Sparse Matrix Multiplication (there is obviously a better solution. re-do.)
1244. Design A Leaderboard (very slow. re-do!)
1256. Encode Number (a math problem, f(n) = f((n - 1) / 2) + "10"[n / 2])
1272. Remove Interval (just be careful. Google problem.)
1213. Intersection of Three Sorted Arrays (very good practise two two pointers. there is a better solution.)
763. Partition Labels (I did not figure out the solution. Definitely re-do!!!)
624. Maximum Distance in Arrays (I did not figure out the solution. Re-do!!)
245. Shortest Word Distance III (do not necessarily save position. re-do. But lower priority.)
1403. Minimum Subsequence in Non-Increasing Order (study the priority queue solution.)
1561. Maximum Number of Coins You Can Get (the trick is to let the third person take the last 1/3.)
1057. Campus Bikes (my original idea was sort based on set. It was out of time limit. The trick is that we know the distance range will be from 0 to 1998. may re-do.)
1006. Clumsy Factorial (the trick: first 3 elements, and then +, -, *, /. do not make mistakes.)
573. Squirrel Simulation (choose the first nut is the key. needs to consider not only the distance for the squirrel but also needs to consider the saved distance from the tree to the nut.)
462. Minimum Moves to Equal Array Elements II (I did not figure out the solution. The trick is to find the median element, not the average! The median is found by using nth_element algorithm. re-do!)
1109. Corporate Flight Bookings (a range sum problem. Do not make mistakes.)
1131. Maximum of Absolute Value Expression (did not figure out the solution. Do it later!)
1296. Divide Array in Sets of K Consecutive Numbers (it is a Google problem. It is highly easy to make mistakes. re-do!!! The next element may not be continuous. e.g. 1,2,3,5,6,7 (3 and 5 are not continuous) The given solution is to check the next k elements have the same frequency. may re-do using this!)
667. Beautiful Arrangement II (failed to solve. A Google problem. Solve it later! Definitely do it! Have solved it. Note that odd and even situations for k are different!!!)
1041. Robot Bounded In Circle (if flip direction or change 0, it is a circle. re-do if does not know the previous sentence.)
1358. Number of Substrings Containing All Three Characters (I did not figure out the solution and it is too slow! use sliding window to re-do it!!!)
592. Fraction Addition and Subtraction (use std::gcd, std::lcm. made so many mistakes. re-do!!!)
360. Sort Transformed Array (the key is that when a >= 0, the curve is high-low-high, and when a < 0, the curve is low-high-low. (when a = 0, it depends on how you choose next.) two pointers problem. re-do!!!)
1582. Special Positions in a Binary Matrix (what should I say... re-do. did not do it very well. Notice the given solution. Two passes. Similar to #531 lonely-pixel-i.)
1366. Rank Teams by Votes (very good sorting problem. re-do!)
648. Replace Words (the given solution is trie. Revisit later. Re-do.)
1452. People Whose List of Favorite Companies Is Not a Subset of Another List (sort beforehand can speed it up. re-do!)
1509. Minimum Difference Between Largest and Smallest Value in Three Moves (note all the possibilities)
1016. Binary String With Substrings Representing 1 To N (time: O(N * (log(N) + S)). space: O(log(N)). only needs to check N to N / 2, for i = 1 to N/2, N to N / 2 can incorporate them.)
1093. Statistics from a Large Sample (the median is obtained by pre_sum and current_sum. Even and odd conditions are tested. be careful.)
986. Interval List Intersections (two pointers. do not make mistakes. re-do! sometimes only found issues when the problematic case is given. what if it is not?)
1150. Check If a Number Is Majority Element in a Sorted Array (first use lower_bound to find the first appearance.)
1014. Best Sightseeing Pair (go through A[j] - j, and for each, find the previous max and add them together. re-do!)
926. Flip String to Monotone Increasing (go through from left to right, record how many 1s. go through from right to left, record how many 0s. Note that it is possible all 0s and all 1s.)
423. Reconstruct Original Digits from English (can first deduce the numbers with the unique letters.)
1418. Display Table of Food Orders in a Restaurant (the biggest issue for me to handle hash table is speed.)
524. Longest Word in Dictionary through Deleting (essense: from 'axdsfbsdfc', see whether 'abc' is a substring by deleting. categarize based on 26 letters, and then sequetially upper_bound the position in each category. re-do! made so many mistakes.)
75. Sort Colors (in place algorithm, mine is the fastest.)
1099. Two Sum Less Than K (look at the other solutions! re-do!!!)
611. Valid Triangle Number (could have been faster? re-do.)
593. Valid Square (the points can coincide, the length can be 1 or 2 or others, re-do)
1503. Last Moment Before All Ants Fall Out of a Plank (brainteaser!)
495. Teemo Attacking (check overlapping. Easy since the duration is constant.)
1185. Day of the Week (interesting. leap year: not 100 years, can be divide by 4; 100 years, can be divided by 400)
676. Implement Magic Dictionary (save the words without a letter into a hash map)
244. Shortest Word Distance II (do not make mistakes)
554. Brick Wall (the key is to use pre_sum and change the numbers into hash table.)
1598. Crawler Log Folder (use stack to solve it. It may not be straitforward if did not know using stack at the beginning.)
1381. Design a Stack With Increment Operation (take away: pop_back() returns void. cannot use pop_back() and back(), they indicate the last element of the entire vector. may or may not re-do)
921. Minimum Add to Make Parentheses Valid (use stack to solve this. extend the original string.)
1190. Reverse Substrings Between Each Pair of Parentheses (when encountered ')', pop until '(', and then push backwards. It is O(n^2). Look at Lee's solution, which is O(n). May re-do.)
1152. Analyze User Website Visit Pattern (it needs to clarify that: the timestamp is not sequential, the username is not sequential. the combination of three websites can be easily obtained by three loops)
1424. Diagonal Traverse II (use std::sort combined with lambda function to sort it.)
853. Car Fleet (the trick is to first sort the cars by position, and then loop from right to left. if the next car cannot catch the current one, the next car is the previous car. re-do.)
1288. Remove Covered Intervals (be careful. do not make mistakes. re-do! there can be two situations, one is (1, 2), (1, 4)... another is (1, 10), (2, 8)...)
792. Number of Matching Subsequences (This example illustrates how important to use pointer or reference to speedup!!! Look at the solution in the discussions! re-do.)
1138. Alphabet Board Path (should be easy. The special place is at (5, 0) to other locations.)
247. Strobogrammatic Number II (The trick is from center to outside do recursions. For each pair: 6,9 and 9,6 or (0,0, 1,1, 8,8). Outside cannot be 0,0. My solution is relatively slow....)
1428. Leftmost Column with at Least a One (For each row, do binary search to find the left most element with 1. A very good practise problem. Can re-do.)
1608. Special Array With X Elements Greater Than or Equal X (first sort and then keep on increasing x. if the found num is smaller than x, -1.)
1297. Maximum Number of Occurrences of a Substring (seems like a sliding window problem. For each substr, use a window to track the number of unique letters and keep on updating it when sliding. The tricky part is that we only need to check minSize, as the larger sizes contains the situations of smaller size ones!!! Also, the max freq of any substr. There may be duplicate or may be not.)
1535. Find the Winner of an Array Game (not hard. Go through the array. Keep track of first ele, if freq == k, return. otherwise, if found max_ele, return. otherwise, return max_ele.)
1282. Group the People Given the Group Size They Belong To (not very hard, but solution kind of slow. Greedy.)
16. 3Sum Closest (idea: first num from 0th element to n-1th element. for the other two elements, use two pointers to track the closest. similar to the 3sum problem.)
870. Advantage Shuffle (The trick is that first compare the largest between A and B, if found that A <= B, then choose the minimal element, otherwise, choose A. very good greedy practise. re-do!!!!)
670. Maximum Swap (The key is that find the max digit, and then swap it between the left most and right most max digit!!! re-do!!)
775. Global and Local Inversions (algorithm: from end to start, keep track of the minimum (keep one element apart from cur), and if cur > minimum, return false.)
1058. Minimize Rounding Error to Meet Target (greedy. floor all the prices and compare with target. The difference is filled by those closeset to original prices.)
452. Minimum Number of Arrows to Burst Balloons (Be careful. Do not make mistakes. Made so many mistakes. re-do!)
1005. Maximize Sum Of Array After K Negations (Greedy. The key is that convert from smallest negative value, and keep track of the minimal positive value.)
874. Walking Robot Simulation (Simulation. Can use customized unordered_set.)
962. Maximum Width Ramp (See the other solutions!!! Re-do later!!!)
1564. Put Boxes Into the Warehouse I (sort the box and get the min_value of warehouse from left to right, and then use two pointers to get the solution.)
1524. Number of Sub-arrays With Odd Sum (be careful. it is pre_sum - another pre_sum. also, notice the other solution in the discussion. re-do.)
223. Rectangle Area (Just be careful. The areas not considering the over_lapping may be beyond INT_MAX)
368. Largest Divisible Subset (a dynamic programming problem. O(n^2))
681. Next Closest Time (Permutate all the possibilities. Note that for all the digits which are the same, just return themselves. It is a special case and was not well stated in the problem description.)
445. Add Two Numbers II (list problem. may study the solution in discussions)
469. Convex Polygon (well, be careful of the last two points. Have to extend as it is circular. Also, cross product can be 0. The key is >=, or <=. If both, wrong.)
1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers (use hash table to solve. see the discussions for potential faster solutions.)
2. Add Two Numbers (just be careful. when >= 10, minus; if not, do not need to.)
86. Partition List (two pointers and then connect them. Just be careful!)
339. Nested List Weight Sum (DFS. A good practise.)
1315. Sum of Nodes with Even-Valued Grandparent (Tree. two layers. re-do.)
1302. Deepest Leaves Sum (Tree. pre, in, or post do not matter. The key is to track the deepest layer.)
1490. Clone N-ary Tree (deep clone N-ary tree.)
366. Find Leaves of Binary Tree (Tree problem. A very good problem. The key is to track the depth and assign to the vector. If the depth is beyond the vector size, resize the vector.)
1448. Count Good Nodes in Binary Tree (Tree problem. Just keep track of the max element along the way!)

*Problem 392: one string is a substring of another, re-visit.

*Problems 503, 1475 in Leetcode:

Similarity: find the next element which is greater or smaller than the current one. The complexity in space and time can be O(n). 

*convert string to lowercase (can use transform as shown below or write one myself)
Example:
std::string data = "Abc";
std::transform(data.begin(), data.end(), data.begin(), [](unsigned char c){ return std::tolower(c); });
    
*string's length: .length()

*10 ways to convert a char to string in C++:

https://www.techiedelight.com/convert-char-to-string-cpp/

*std::vector does not have push_front

*<cstdlib> (stdlib.h)
http://www.cplusplus.com/reference/cstdlib/

*random number generator:
#include <time.h>  
srand(time(NULL)); 
int j = rand() % max_number; //generate a number between (0, max_number - 1)  

*reverse loop through an array:
wrong: for (size_t i = a_vector.size(); i >= 0; i--)
correct: for (int i = a_vector.size(); i >= 0; i--)

*char and integer correspondance:
'A' <-> 65
'a' <-> 97

*for single digit number char, e.g. '9' - '0' can be 9!

*the middle element:
Given an array with size n. If n is odd, n / 2 will give the exact middle element and if n is even, n / 2 will give the right one of the middle two elements.

*string find_first_of, find_last_of:
while (i < j) {
    i = s.find_first_of("aeiouAEIOU", i);
    j = s.find_last_of("aeiouAEIOU", j);
    if (i < j) {
        swap(s[i++], s[j--]);
    }
}

*std::swap

*comparison of values of size_t and int. The int number will be casted to size_t automatically.

//Example
#include <iostream>
using namespace std;
int main()
{
   size_t i = 1;
   int j = -1;
   
   std::cout << (i > j) << std::endl;
   std::cout << (j < i) << std::endl;
   std::cout << (i < j) << std::endl;
   std::cout << (j > i) << std::endl;
   
   return 0;
}
//Output
0
0
1
1

*count frequency of an element in a set(unordered_set): a_set.count(an_element)

*cctype library:

//notice that there are no '_' in the methods below!
#include <cctype>
isalpha()
isalnum()
isdigit()
tolower() 
toupper()

*stack: when stack.empty(), stack.pop() is erroneous

*substr: a_string(a_position, 0) is legal

*string: valid methods: push_back(), pop_back, a_string.back()

*append: for C++, only string library have 'append' method.

*Problem 225: implement stack using queues

Note: we can either use one or two queues to achieve this.

*stringstream example:

Example:
process string separated by space:

        stringstream ss(sentence);
        
        size_t count = 0;
        
        string token;
        
        while (ss >> token)
        {
            
            if (token.substr(0, searchWord.size()) == searchWord) return count + 1;
            
            count++;
        }
        
Example:
process string separated by comma:

#include <iostream>
#include <sstream>

int main()
{
    std::string input = "abc, def,  ghi";
    std::istringstream ss(input);
    std::string token;
    
    while(std::getline(ss, token, ',')) {
        std::cout << token << '\n';
    }

    return 0;
}

output:
abc                                                                                                                                                                                  
 def                                                                                                                                                                                 
  ghi
  
*count (can be used for string, vector, etc)

#include <iostream>
#include <algorithm>
using namespace std; 
  
int main() 
{ 
    string str = "geeksforgeeks"; 
  
    cout << "Number of times 'e' appears : " 
         << count(str.begin(), str.end(), 'e'); 
  
    return 0; 
} 

*string: string::npos equals to -1

*set (multiset) erase: 

erase(a_set.begin()): only erases the iterater!
erase(*a_set.begin()): erase all the elements with the value!

*std::upper_bound: returns an iterator pointing to the first element in the range [first,last) which compares greater than val.

*std::lower_bound: returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.

*first and last element: .front() and .back() for std::vector, std::list, std::queue, std::string

*distance between iterations: std::distance

*1051. Height Checker:
the multiset sort can be replaced by a vector or unordered_map

*1E3 and 10E3 are different and 1E3 is default double 

*-3 % 2 equals to -1 not 1!

*std::equal_range for a sorted sequence
http://www.cplusplus.com/reference/algorithm/equal_range/

*emplace for unordered_map
Example:
        std::unordered_map <int, int> map_val_rank;
        
        for (const auto& item : arr_copy)
        {
            map_val_rank.emplace(item, map_val_rank.size() + 1);
        }
        
*binary search prototype:
441. Arranging Coins
    long left = 0, right = n;
    long k, curr;
    while (left <= right)
    {
        k = left + (right - left) / 2;

        curr = k * (k + 1) / 2;

        if (curr == n) return k;

        if (n < curr) right = k - 1;
        else left = k + 1;

        std::cout << "left, right: " << left << ", " << right << std::endl;
    }
    
*a square number is 1+3+5+7+...

*-1 is also considered to be true!

Example:
#include <iostream>

using namespace std;

int main()
{
   if (-1)
   {
       std::cout << "Test a1\n";
   }
   
   return 0;
}

Output:
Test a1

*divide by 0:
cout << 5 / 0 << endl; //error
cout << 1.0 * 5 / 0 << endl; //ok

*floor and ceil

*numeric_limits:
Example:
#include <iostream>
#include <limits>
int main()
{
    double max = std::numeric_limits<double>::max();
    double inf = std::numeric_limits<double>::infinity();
 
    if(inf > max)
        std::cout << inf << " is greater than " << max << '\n';
}
Example:
std::numeric_limits <int>::infinity(); //returns 0!!!!! seems only working for floating numbers

*'-' cannot be used in variable name. 
Example:
string letter-log; //error

*string insert format:
Example:
a_string.insert(position, count, a_char)

string& insert (size_t pos, const string& str);
string& insert (size_t pos, const string& str, size_t subpos, size_t sublen);
string& insert (size_t pos, const char* s);
string& insert (size_t pos, const char* s, size_t n);
string& insert (size_t pos, size_t n, char c);
void insert (iterator p, size_t n, char c);
iterator insert (iterator p, char c);
template <class InputIterator>
void insert (iterator p, InputIterator first, InputIterator last);

*for an array of size n, if n % 2 == 1, the middle element index is n / 2, and if n % 2 == 0, the middle right element index is n / 2 (assume element starts from 0).

*multimap: overloading [], wrong!
Example:
a_map[a] = b; //wrong!

*find(vector_of_vector.begin(), vector_of_vector.end(), {a, b}) //wrong expression, cannot use {a, b}

*sort(a.begin(), a.end()) //note that for sort, the end position is the real find position + 1

*gcd, lcm since C++17

*std::cout << -3 % (-2) << std::endl; //result -1, the quotient is closer to 0

*note that for iterating through the vector, sometimes forgot to update the operations of the last element:
Example:
        int pre_diff = A[1] - A[0];
        int count = 1;
        for (int i = 0; i < A.size() - 1; ++i)
        {
            int diff = A[i + 1] - A[i];
            
            if (diff == pre_diff && i != A.size() - 2)
            {
                count++;
            }
            else if (diff == pre_diff && i == A.size() - 2)
            {
                count++;
                consecutive.push_back(count);
            }
            else if (diff != pre_diff)
            {
                if (count >= 3) consecutive.push_back(count);
                
                pre_diff = diff;
                count = 2;
            }
        }

*int64_t, int32_t

*sliding window: note the less or equal to, and note the overflow (problem 1343)

*__builtin_popcount(int) function is used to count the number of one’s(set bits) in an integer.

*std::sort(a_string.begin(), a_string.end()); //it works for C++ to sort a string.

*numeric_limits:

Example:

#include <limits>
#include <iostream>
 
int main() 
{
    std::cout << "type\tlowest()\tmin()\t\tmax()\n\n";
 
    std::cout << "uchar\t"
              << +std::numeric_limits<unsigned char>::lowest() << '\t' << '\t'
              << +std::numeric_limits<unsigned char>::min() << '\t' << '\t'
              << +std::numeric_limits<unsigned char>::max() << '\n';
    std::cout << "int\t"
              << std::numeric_limits<int>::lowest() << '\t'
              << std::numeric_limits<int>::min() << '\t'
              << std::numeric_limits<int>::max() << '\n';
    std::cout << "float\t"
              << std::numeric_limits<float>::lowest() << '\t'
              << std::numeric_limits<float>::min() << '\t'
              << std::numeric_limits<float>::max() << '\n';
    std::cout << "double\t"
              << std::numeric_limits<double>::lowest() << '\t'
              << std::numeric_limits<double>::min() << '\t'
              << std::numeric_limits<double>::max() << '\n';
}

type	lowest()	min()		max()
uchar	0		0		255
int	-2147483648	-2147483648	2147483647
float	-3.40282e+38	1.17549e-38	3.40282e+38
double	-1.79769e+308	2.22507e-308	1.79769e+308

*std::string::erase
sequence (1)	
string& erase (size_t pos = 0, size_t len = npos);
character (2)	
iterator erase (iterator p);
range (3)	
iterator erase (iterator first, iterator last);

*it = lower_bound(it, A.end(), cur); //A is a sorted vector of string, and cur is a string. 
You can use lower bound to find the first element in the vector which matches cur. The complexity is log(N).

*erase-remove idiom
https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom
https://stackoverflow.com/questions/3385229/c-erase-vector-element-by-value-rather-than-by-position
#include <algorithm>
...
vec.erase(std::remove(vec.begin(), vec.end(), 8), vec.end());
This combination is also known as the erase-remove idiom.

*std::accumulate with lambda function
Example:
return accumulate(begin(res), end(res), 0, [&](int s, int i) { return s + n[i] * vec.n[i]; });

Example:
#include <vector>
#include <algorithm>
#include <iostream>
#include <numeric>
using namespace std;
std::vector<int> v = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

int main()
{
    auto lambda = [&](double a, double b){return a + b / v.size(); };
    std::cout << std::accumulate(v.begin(), v.end(), 0.0, lambda) << std::endl;
}

*set_intersection
Example:
vector<int> res;
set_intersection(begin(v), end(v), begin(vec.v), end(vec.v), back_inserter(res));

*set_intersection of two vectors. Two pointers:
1570. Dot Product of Two Sparse Vectors
Example:
int dotProduct(SparseVector& vec, int res = 0) {
    for (int i = 0, j = 0; i < v.size() && j < vec.v.size(); ++i, ++j)
        if (v[i].first < vec.v[j].first)
            --j;
        else if (v[i].first > vec.v[j].first)
            --i;
        else
            res += v[i].second * vec.v[j].second;
    return res;
}

*out of range error for 'for loop':
Example:
for (int i = 0; i <= (int) (S.length() - K); ++i) //if 'S.length() - K' is not converted to int, error is generated!!!

*nth_element:
Example:
int n = nums.size();
auto it = nums.begin() + n/2;
nth_element(nums.begin(), it, nums.end());
int median = *it;

*sort by function example:
1333. Filter Restaurants by Vegan-Friendly, Price and Distance
Example:
    static bool cmp(const vector<int>& v1, const vector<int>& v2) {
        return v1[1] == v2[1] ? v1[0] > v2[0] : v1[1] > v2[1];
    }
    
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        vector<vector<int>> res;
        
        for(int i = 0; i < restaurants.size(); i++) {
            if (!restaurants[i][2] && veganFriendly) continue;//be careful
            if(restaurants[i][3] > maxPrice) continue;
            if(restaurants[i][4] > maxDistance) continue;
            res.push_back(restaurants[i]);
        }
        
        sort(res.begin(), res.end(), cmp);
        
        vector<int> ids;
        for(int i = 0; i < res.size(); i++) ids.push_back(res[i][0]);
        return ids;
    }
    
*accumulate
Example
std::accumulate(a_vec.begin(), a_vec.end(), 0); //if a_vec is of double, it will be casted into int!!!
    
*includes
Example:
found = std::includes(comp2.begin(), comp2.end(), comp1.begin(), comp1.end()); //note that comp1 and comp2 need to be sorted

*this->small = small //note that in a class, 'this' is used so that identical names can be used.

*erase while iterating
example:
for(it2 = uc.begin(); it2 != uc.end();)
{
   ...   
   if(...)
   {
      it2 = uc.erase(it2); //the key!
   }
   else
   {
      ++it2;
   }
   ...
}

*practice: convert a string into a string of sequential unique characters, e.g.: convert "aaaabbbbccdde" into 'abcde'. The tricky part is the first and last position!!!

*practise: identify intervals of continuous 1s. 1513. Number of Substrings With Only 1s

*priority_queue:
https://en.cppreference.com/w/cpp/container/priority_queue
A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.

*multi-dimensional array, memset
Example:
int dp[m + 1][n + 1][4];
memset(dp, 0, sizeof dp);
std::cout << "there are: " << sizeof dp / sizeof(int) << " elements." << std::endl;

*long int:
Example
1L

*unordered_set with pair!!!:
Use an operator!
Example:
#include <iostream>
#include <unordered_set>

using namespace std;

struct PositionHash
{
    size_t operator()(const pair<int, int> &val) const
    {
        return val.first ^ val.second;
    }
};

int main()
{
   unordered_set<pair<int, int>, PositionHash> obs;
   
   obs.insert({1,2});
   obs.insert({1000000000, 1000000000});
   
   return 0;
}

