*Remembered problems:

1. The rainfall volumes between the mountains

2. randomly shuffle an array of numbers

3. a string problem?

4. rvalue reference

5. hash table

6. virtual table?

7. rvalue reference

7. Chicago trading interview problem

7. HackerRank

7. Two's complement?

7. What is a priority queue? 

7. What is a sliding window algorithm?

8. very important re-visit problems:
767. Reorganize String (a very important problem! Did not figure out the solution at the beginning at all. Have to re-do!!! trick: from 1 to ..., and then from 0 to ... if a char is larger than (N + 1) / 2. no such solution...)
1062. Longest Repeating Substring (the current solution is pretty slow although can pass. Re-do! Reference the given solution.)
1023. Camelcase Matching (string and trie?????)
357. Count Numbers with Unique Digits (failed to solve. Two approaches. Re-do!!!!)
279. Perfect Squares (dynamic programming! do not make mistakes. re-do!)
729. My Calendar I (my lord. I had no clue at all! very hard to me! use set and lower_bound. re-do!!!!)
991. Broken Calculator (failed to work it out. very important. re-do!!!)
313. Super Ugly Number (had no clue at all!!!)
1072. Flip Columns For Maximum Number of Equal Rows (XOR. No clue at all. re-do!!!)

8. re-visit problems: 
1004. (sliding window) 
1237.
1446. Consecutive Characters
303. Range Sum Query - Immutable
696. Count Binary Substrings
1071. Greatest Common Divisor of Strings
1089. Duplicate Zeros (there is a better solution)
441. Arranging Coins
1539. Kth Missing Positive Number (next time resolve it using binary search)
1275. Find Winner on a Tic Tac Toe Game (good practice to consider the corner cases)
989. Add to Array-Form of Integer (notice the given solution method in Java)
937. Reorder Data in Log Files (a hard problem!)
507. Perfect Number (re-visit!)
168. Excel Sheet Column Title (interesting)
453. Minimum Moves to Equal Array Elements
189. Rotate Array (must try the O(1) extra space method!)
532. K-diff Pairs in an Array (notice that k can be <0, == 0, and > 0, and same numbers only count once)
414. Third Maximum Number (consider using one loop)
535. Encode and Decode TinyURL (what is tinyURL?)
953. Verifying an Alien Dictionary (compare adjacent string, re-do)
447. Number of Boomerangs (notice that for each point, generate a hash map)
299. Bulls and Cows (re-do, think about some faster method)
1556. Thousand Separator (make sure pass one time. 1. a_string.insert(position, count, char) 2. do not add '.' at position = 0)
1277. Count Square Submatrices with All Ones (dynamic programming, the 1D index one does not work because i, j are both updated! May look for better solutions in discussions?)
1433. Check If a String Can Break Another String (failed to work it out. Re-do!)
1104. Path In Zigzag Labelled Binary Tree (interesting, worth re-do)
1442. Count Triplets That Can Form Two Arrays of Equal XOR (definitely re-do, needs some derivations on XOR operations)
885. Spiral Matrix III (failed to work it out, re-do!)
338. Counting Bits (needs to re-visit sometime, remember the equation)
442. Find All Duplicates in an Array (re-do, two solutions, one is the one I figure out, the other is the solution in discussions)
969. Pancake Sorting (may worth re-do)
1338. Reduce Array Size to The Half (be careful, do not make mistakes)
877. Stone Game (failed to work out. Re-do! Dynamic programming dp(i, j), starts from dp(i,i) and then increase the i, j difference. Definitely worth re-doing)
1344. Angle Between Hands of a Clock (not hard, but be careful, do not mistake double to int, and each hour corresponds to 5 in the 60 circle)
1227. Airplane Seat Assignment Probability (dynamic programming problem. Although the solution is guessed. It is great if can derive later.)
1447. Simplified Fractions (from small to large number, if gcd(i,j) == 1 accumulate)
1017. Convert to Base -2 (remember the formula)
413. Arithmetic Slices (made too many mistakes, re-do)
665. Non-decreasing Array (definitely re-do, for i, first change (i - 1) if (i - 2) <= i, else change i == i - 1) 
1508. Range Sum of Sorted Subarray Sums (sliding window and do not make mistakes)
1362. Closest Divisors (be careful, do not make mistakes, priority_queue solution?)
553. Optimal Division (maybe understand the problem better?)
1233. Remove Sub-Folders from the Filesystem (I did not figure out this solution. Have to re-do.)
1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold (sliding window, note less or equal to, and note the overflow, can also be solved by presum)
1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K (greedy approach; did not figure out the solution myself)
1375. Bulb Switcher III (two steps; keep track of the right most bulb; did not figure out the solution myself)
1566. Detect Pattern of Length M Repeated K or More Times (there is another O(n) solution)
1437. Check If All 1's Are at Least Length K Places Away (be careful not to make mistakes, may worth re-do)
1493. Longest Subarray of 1's After Deleting One Element (I have no idea about the solution!!! Resolve it later with the other sliding window problems!!!)
290. Word Pattern (made so many mistakes! Read solution)
762. Prime Number of Set Bits in Binary Representation (note the __builtin_popcount solution and the bitset<32>(i).count() solution)
781. Rabbits in Forest (note the use of map, key: total rabbits of same color, value: accumulated rabbits. Note that do not forget to add all the remaining map keys)
858. Mirror Reflection (I did not figure out this solution. This is done by mirroring the blocks. It needs some drawings and summary.)
963. Minimum Area Rectangle II (in my opinion, a hard problem. Have to remember to use centroid and diagonal length.)
1011. Capacity To Ship Packages Within D Days (a phenominon binary search problem. According to the discussions, similar problems are 

1482. Minimum Number of Days to Make m Bouquets
1283. Find the Smallest Divisor Given a Threshold
1231. Divide Chocolate
1011. Capacity To Ship Packages In N Days
875. Koko Eating Bananas
774. Minimize Max Distance to Gas Station
410. Split Array Largest Sum
)

1031. Maximum Sum of Two Non-Overlapping Subarrays (This question is worth re-do. Two pre_sum. Do not make mistakes.)
1267. Count Servers that Communicate (not hard but do not make mistakes, j and a_vector[i][j] are different! The solution in the discussions is great.)
48. Rotate Image (I did not figure out the solution. First top and bottom rows reverse. Second diagonal swap.)
1471. The k Strongest Values in an Array (Lession learned: 1. Read the problem statement carefully. The returned values are the arr elements. 2. Do not forget corner cases. In this case, arr.size() == 1.)
216. Combination Sum III (Failed to solve. Backtracking problem!!!!! Using my methods keep passing time limit. The key is to keep increasing the next element.
This is an important problem. Should try doing later several times.)
39. Combination Sum (worth re-do. Similar to problem 216.)
22. Generate Parentheses (worth re-do. Another backtracking problem.)
1111. Maximum Nesting Depth of Two Valid Parentheses Strings (Did not understand the problem. Re-do! The trick is to split even as much as possible. The odd and even parentheses are separated into A and B respectively.)
287. Find the Duplicate Number (my unique way of resolving it)
1249. Minimum Remove to Make Valid Parentheses (stack is used. sometimes slow down the writing can avoid a lot of logic and typo errors.)
856. Score of Parentheses (failed to solve. do not make mistakes. the trick: count number of '(', if found '(' and next is ')', add the score; if only found ')', decrease the number of '('.re-solve later!!!!!!)
1035. Uncrossed Lines (dynamic programming, I did not figure out the solution. Re-do!!!)
256. Paint House (dynamic programming, I did not figure out the solution. Re-do. The DP can be 2D!)
276. Paint Fence (dynamic programming, I did not figure out the solution. Re-do. Needs some derivations.)
1043. Partition Array for Maximum Sum (dynamic programming. I did not figure out the solution. This is a hard problem! The key is that for any element, goes back from 1 to k, and see which one is the largest. re-do!!!)
758. Bold Words in String (made so many mistakes!! re-do!!! a_string.find(another_string, start_position)!!! inserting something into a string is awlays a pain!)
1286. Iterator for Combination (very interesting problem for backtracking. Figured out myself. Do not forget return. Worth re-do.)
1198. Find Smallest Common Element in All Rows (Of lower priority to re-do. Use set_intersection to solve the problem. the container types need to be the same)
1056. Confusing Number (Of lower priority to re-do. Note that the rotation is not based on each digit but based on the entire number.)
370. Range Addition (range addition time complexity can be O(m + n). I did not work it out myself. A Google problem. Definitely worth re-do!!)
1151. Minimum Swaps to Group All 1's Together (classic sliding window problem! worth re-do! Do not make mistakes)
565. Array Nesting (I did not figure out the solution. The trick is that once the number is involed, it is no longer involved. Definitely do it again.)
311. Sparse Matrix Multiplication (there is obviously a better solution. re-do.)
1244. Design A Leaderboard (very slow. re-do!)
1256. Encode Number (a math problem, f(n) = f((n - 1) / 2) + "10"[n / 2])
1272. Remove Interval (just be careful. Google problem.)
1213. Intersection of Three Sorted Arrays (very good practise two two pointers. there is a better solution.)
763. Partition Labels (I did not figure out the solution. Definitely re-do!!!)
624. Maximum Distance in Arrays (I did not figure out the solution. Re-do!!)
245. Shortest Word Distance III (do not necessarily save position. re-do. But lower priority.)
1403. Minimum Subsequence in Non-Increasing Order (study the priority queue solution.)
1561. Maximum Number of Coins You Can Get (the trick is to let the third person take the last 1/3.)
1057. Campus Bikes (my original idea was sort based on set. It was out of time limit. The trick is that we know the distance range will be from 0 to 1998. may re-do.)
1006. Clumsy Factorial (the trick: first 3 elements, and then +, -, *, /. do not make mistakes.)
573. Squirrel Simulation (choose the first nut is the key. needs to consider not only the distance for the squirrel but also needs to consider the saved distance from the tree to the nut.)
462. Minimum Moves to Equal Array Elements II (I did not figure out the solution. The trick is to find the median element, not the average! The median is found by using nth_element algorithm. re-do!)
1109. Corporate Flight Bookings (a range sum problem. Do not make mistakes.)
1131. Maximum of Absolute Value Expression (did not figure out the solution. Do it later!)
1296. Divide Array in Sets of K Consecutive Numbers (it is a Google problem. It is highly easy to make mistakes. re-do!!! The next element may not be continuous. e.g. 1,2,3,5,6,7 (3 and 5 are not continuous) The given solution is to check the next k elements have the same frequency. may re-do using this!)
667. Beautiful Arrangement II (failed to solve. A Google problem. Solve it later! Definitely do it!)
1041. Robot Bounded In Circle (if flip direction or change 0, it is a circle. re-do if does not know the previous sentence.)
1358. Number of Substrings Containing All Three Characters (I did not figure out the solution and it is too slow! use sliding window to re-do it!!!)
592. Fraction Addition and Subtraction (use std::gcd, std::lcm. made so many mistakes. re-do!!!)
360. Sort Transformed Array (the key is that when a >= 0, the curve is high-low-high, and when a < 0, the curve is low-high-low. (when a = 0, it depends on how you choose next.) two pointers problem. re-do!!!)
1582. Special Positions in a Binary Matrix (what should I say... re-do. did not do it very well. Notice the given solution. Two passes. Similar to #531 lonely-pixel-i.)
1366. Rank Teams by Votes (very good sorting problem. re-do!)
648. Replace Words (the given solution is trie. Revisit later. Re-do.)
1452. People Whose List of Favorite Companies Is Not a Subset of Another List (sort beforehand can speed it up. re-do!)
1509. Minimum Difference Between Largest and Smallest Value in Three Moves (note all the possibilities)
1016. Binary String With Substrings Representing 1 To N (time: O(N * (log(N) + S)). space: O(log(N)). only needs to check N to N / 2, for i = 1 to N/2, N to N / 2 can incorporate them.)
1093. Statistics from a Large Sample (the median is obtained by pre_sum and current_sum. Even and odd conditions are tested. be careful.)
986. Interval List Intersections (two pointers. do not make mistakes. re-do! sometimes only found issues when the problematic case is given. what if it is not?)
1150. Check If a Number Is Majority Element in a Sorted Array (first use lower_bound to find the first appearance.)
1014. Best Sightseeing Pair (go through A[j] - j, and for each, find the previous max and add them together. re-do!)
926. Flip String to Monotone Increasing (go through from left to right, record how many 1s. go through from right to left, record how many 0s. Note that it is possible all 0s and all 1s.)
423. Reconstruct Original Digits from English (can first deduce the numbers with the unique letters.)
1418. Display Table of Food Orders in a Restaurant (the biggest issue for me to handle hash table is speed.)
524. Longest Word in Dictionary through Deleting (essense: from 'axdsfbsdfc', see whether 'abc' is a substring by deleting. categarize based on 26 letters, and then sequetially upper_bound the position in each category. re-do! made so many mistakes.)
75. Sort Colors (in place algorithm, mine is the fastest.)

*Problem 392: one string is a substring of another, re-visit.

*Problems 503, 1475 in Leetcode:

Similarity: find the next element which is greater or smaller than the current one. The complexity in space and time can be O(n). 

*string's length: .length()

*10 ways to convert a char to string in C++:

https://www.techiedelight.com/convert-char-to-string-cpp/

*std::vector does not have push_front

*<cstdlib> (stdlib.h)
http://www.cplusplus.com/reference/cstdlib/

*random number generator:
#include <time.h>  
srand(time(NULL)); 
int j = rand() % max_number; //generate a number between (0, max_number - 1)  

*reverse loop through an array:
wrong: for (size_t i = a_vector.size(); i >= 0; i--)
correct: for (int i = a_vector.size(); i >= 0; i--)

*char and integer correspondance:
'A' <-> 65
'a' <-> 97

*the middle element:
Given an array with size n. If n is odd, n / 2 will give the exact middle element and if n is even, n / 2 will give the right one of the middle two elements.

*string find_first_of, find_last_of:
while (i < j) {
    i = s.find_first_of("aeiouAEIOU", i);
    j = s.find_last_of("aeiouAEIOU", j);
    if (i < j) {
        swap(s[i++], s[j--]);
    }
}

*std::swap

*comparison of values of size_t and int. The int number will be casted to size_t automatically.

//Example
#include <iostream>
using namespace std;
int main()
{
   size_t i = 1;
   int j = -1;
   
   std::cout << (i > j) << std::endl;
   std::cout << (j < i) << std::endl;
   std::cout << (i < j) << std::endl;
   std::cout << (j > i) << std::endl;
   
   return 0;
}
//Output
0
0
1
1

*count frequency of an element in a set(unordered_set): a_set.count(an_element)

*cctype library:

//notice that there are no '_' in the methods below!
#include <cctype>
isalpha()
isalnum()
isdigit()
tolower() 
toupper()

*stack: when stack.empty(), stack.pop() is erroneous

*substr: a_string(a_position, 0) is legal

*string: valid methods: push_back(), pop_back, a_string.back()

*append: for C++, only string library have 'append' method.

*Problem 225: implement stack using queues

Note: we can either use one or two queues to achieve this.

*stringstream example:

Example:
process string separated by space:

        stringstream ss(sentence);
        
        size_t count = 0;
        
        string token;
        
        while (ss >> token)
        {
            
            if (token.substr(0, searchWord.size()) == searchWord) return count + 1;
            
            count++;
        }
        
Example:
process string separated by comma:

#include <iostream>
#include <sstream>

int main()
{
    std::string input = "abc, def,  ghi";
    std::istringstream ss(input);
    std::string token;
    
    while(std::getline(ss, token, ',')) {
        std::cout << token << '\n';
    }

    return 0;
}

output:
abc                                                                                                                                                                                  
 def                                                                                                                                                                                 
  ghi
  
*count (can be used for string, vector, etc)

#include <iostream>
#include <algorithm>
using namespace std; 
  
int main() 
{ 
    string str = "geeksforgeeks"; 
  
    cout << "Number of times 'e' appears : " 
         << count(str.begin(), str.end(), 'e'); 
  
    return 0; 
} 

*string: string::npos equals to -1

*set (multiset) erase: 

erase(a_set.begin()): only erases the iterater!
erase(*a_set.begin()): erase all the elements with the value!

*std::upper_bound: returns an iterator pointing to the first element in the range [first,last) which compares greater than val.

*std::lower_bound: returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.

*first and last element: .front() and .back() for std::vector, std::list, std::queue, std::string

*distance between iterations: std::distance

*1051. Height Checker:
the multiset sort can be replaced by a vector or unordered_map

*1E3 and 10E3 are different and 1E3 is default double 

*-3 % 2 equals to -1 not 1!

*std::equal_range for a sorted sequence
http://www.cplusplus.com/reference/algorithm/equal_range/

*emplace for unordered_map
Example:
        std::unordered_map <int, int> map_val_rank;
        
        for (const auto& item : arr_copy)
        {
            map_val_rank.emplace(item, map_val_rank.size() + 1);
        }
        
*binary search prototype:
441. Arranging Coins
    long left = 0, right = n;
    long k, curr;
    while (left <= right)
    {
        k = left + (right - left) / 2;

        curr = k * (k + 1) / 2;

        if (curr == n) return k;

        if (n < curr) right = k - 1;
        else left = k + 1;

        std::cout << "left, right: " << left << ", " << right << std::endl;
    }
    
*a square number is 1+3+5+7+...

*-1 is also considered to be true!

Example:
#include <iostream>

using namespace std;

int main()
{
   if (-1)
   {
       std::cout << "Test a1\n";
   }
   
   return 0;
}

Output:
Test a1

*divide by 0:
cout << 5 / 0 << endl; //error
cout << 1.0 * 5 / 0 << endl; //ok

*floor and ceil

*numeric_limits:
Example:
#include <iostream>
#include <limits>
int main()
{
    double max = std::numeric_limits<double>::max();
    double inf = std::numeric_limits<double>::infinity();
 
    if(inf > max)
        std::cout << inf << " is greater than " << max << '\n';
}
Example:
std::numeric_limits <int>::infinity(); //returns 0!!!!! seems only working for floating numbers

*'-' cannot be used in variable name. 
Example:
string letter-log; //error

*string insert format:
Example:
a_string.insert(position, count, a_char)

string& insert (size_t pos, const string& str);
string& insert (size_t pos, const string& str, size_t subpos, size_t sublen);
string& insert (size_t pos, const char* s);
string& insert (size_t pos, const char* s, size_t n);
string& insert (size_t pos, size_t n, char c);
void insert (iterator p, size_t n, char c);
iterator insert (iterator p, char c);
template <class InputIterator>
void insert (iterator p, InputIterator first, InputIterator last);

*for an array of size n, if n % 2 == 1, the middle element index is n / 2, and if n % 2 == 0, the middle right element index is n / 2 (assume element starts from 0).

*multimap: overloading [], wrong!
Example:
a_map[a] = b; //wrong!

*find(vector_of_vector.begin(), vector_of_vector.end(), {a, b}) //wrong expression, cannot use {a, b}

*sort(a.begin(), a.end()) //note that for sort, the end position is the real find position + 1

*gcd, lcm since C++17

*std::cout << -3 % (-2) << std::endl; //result -1, the quotient is closer to 0

*note that for iterating through the vector, sometimes forgot to update the operations of the last element:
Example:
        int pre_diff = A[1] - A[0];
        int count = 1;
        for (int i = 0; i < A.size() - 1; ++i)
        {
            int diff = A[i + 1] - A[i];
            
            if (diff == pre_diff && i != A.size() - 2)
            {
                count++;
            }
            else if (diff == pre_diff && i == A.size() - 2)
            {
                count++;
                consecutive.push_back(count);
            }
            else if (diff != pre_diff)
            {
                if (count >= 3) consecutive.push_back(count);
                
                pre_diff = diff;
                count = 2;
            }
        }

*int64_t, int32_t

*sliding window: note the less or equal to, and note the overflow (problem 1343)

*__builtin_popcount(int) function is used to count the number of oneâ€™s(set bits) in an integer.

*std::sort(a_string.begin(), a_string.end()); //it works for C++ to sort a string.

*numeric_limits:

Example:

#include <limits>
#include <iostream>
 
int main() 
{
    std::cout << "type\tlowest()\tmin()\t\tmax()\n\n";
 
    std::cout << "uchar\t"
              << +std::numeric_limits<unsigned char>::lowest() << '\t' << '\t'
              << +std::numeric_limits<unsigned char>::min() << '\t' << '\t'
              << +std::numeric_limits<unsigned char>::max() << '\n';
    std::cout << "int\t"
              << std::numeric_limits<int>::lowest() << '\t'
              << std::numeric_limits<int>::min() << '\t'
              << std::numeric_limits<int>::max() << '\n';
    std::cout << "float\t"
              << std::numeric_limits<float>::lowest() << '\t'
              << std::numeric_limits<float>::min() << '\t'
              << std::numeric_limits<float>::max() << '\n';
    std::cout << "double\t"
              << std::numeric_limits<double>::lowest() << '\t'
              << std::numeric_limits<double>::min() << '\t'
              << std::numeric_limits<double>::max() << '\n';
}

type	lowest()	min()		max()
uchar	0		0		255
int	-2147483648	-2147483648	2147483647
float	-3.40282e+38	1.17549e-38	3.40282e+38
double	-1.79769e+308	2.22507e-308	1.79769e+308

*std::string::erase
sequence (1)	
string& erase (size_t pos = 0, size_t len = npos);
character (2)	
iterator erase (iterator p);
range (3)	
iterator erase (iterator first, iterator last);

*it = lower_bound(it, A.end(), cur); //A is a sorted vector of string, and cur is a string. 
You can use lower bound to find the first element in the vector which matches cur. The complexity is log(N).

*erase-remove idiom
https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom
https://stackoverflow.com/questions/3385229/c-erase-vector-element-by-value-rather-than-by-position
#include <algorithm>
...
vec.erase(std::remove(vec.begin(), vec.end(), 8), vec.end());
This combination is also known as the erase-remove idiom.

*std::accumulate with lambda function
Example:
return accumulate(begin(res), end(res), 0, [&](int s, int i) { return s + n[i] * vec.n[i]; });

Example:
#include <vector>
#include <algorithm>
#include <iostream>
#include <numeric>
using namespace std;
std::vector<int> v = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

int main()
{
    auto lambda = [&](double a, double b){return a + b / v.size(); };
    std::cout << std::accumulate(v.begin(), v.end(), 0.0, lambda) << std::endl;
}

*set_intersection
Example:
vector<int> res;
set_intersection(begin(v), end(v), begin(vec.v), end(vec.v), back_inserter(res));

*set_intersection of two vectors. Two pointers:
1570. Dot Product of Two Sparse Vectors
Example:
int dotProduct(SparseVector& vec, int res = 0) {
    for (int i = 0, j = 0; i < v.size() && j < vec.v.size(); ++i, ++j)
        if (v[i].first < vec.v[j].first)
            --j;
        else if (v[i].first > vec.v[j].first)
            --i;
        else
            res += v[i].second * vec.v[j].second;
    return res;
}

*out of range error for 'for loop':
Example:
for (int i = 0; i <= (int) (S.length() - K); ++i) //if 'S.length() - K' is not converted to int, error is generated!!!

*nth_element:
Example:
int n = nums.size();
auto it = nums.begin() + n/2;
nth_element(nums.begin(), it, nums.end());
int median = *it;

*sort by function example:
1333. Filter Restaurants by Vegan-Friendly, Price and Distance
Example:
    static bool cmp(const vector<int>& v1, const vector<int>& v2) {
        return v1[1] == v2[1] ? v1[0] > v2[0] : v1[1] > v2[1];
    }
    
public:
    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        vector<vector<int>> res;
        
        for(int i = 0; i < restaurants.size(); i++) {
            if (!restaurants[i][2] && veganFriendly) continue;//be careful
            if(restaurants[i][3] > maxPrice) continue;
            if(restaurants[i][4] > maxDistance) continue;
            res.push_back(restaurants[i]);
        }
        
        sort(res.begin(), res.end(), cmp);
        
        vector<int> ids;
        for(int i = 0; i < res.size(); i++) ids.push_back(res[i][0]);
        return ids;
    }
    
    *accumulate
    Example
    std::accumulate(a_vec.begin(), a_vec.end(), 0); //if a_vec is of double, it will be casted into int!!!
    
    *includes
    Example:
    found = std::includes(comp2.begin(), comp2.end(), comp1.begin(), comp1.end()); //note that comp1 and comp2 need to be sorted
