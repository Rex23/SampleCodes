https://en.wikipedia.org/wiki/Binary_search_algorithm

function binary_search(A, n, T) is
    L := 0
    R := n − 1
    while L ≤ R do
        m := floor((L + R) / 2)
        if A[m] < T then
            L := m + 1
        else if A[m] > T then
            R := m − 1
        else:
            return m
    return unsuccessful
    
function binary_search_leftmost(A, n, T):
    L := 0
    R := n
    while L < R:
        m := floor((L + R) / 2)
        if A[m] < T:
            L := m + 1
        else:
            R := m
    return L
    
function binary_search_rightmost(A, n, T):
    L := 0
    R := n
    while L < R:
        m := floor((L + R) / 2)
        if A[m] > T:
            R := m
        else:
            L := m + 1
    return R - 1

1533. Find the Index of the Large Integer (note the left and right updates, re-do!)
1060. Missing Element in Sorted Array (re-do this by using binary search)
1064. Fixed Point (binary search, note only 1 element special case. re-do!)
875. Koko Eating Bananas (re-do!!! Do not make mistakes. The binary search may not stop for ever)
911. Online Election (I did not figure out the solution. Have to re-do!!! Notice the unordered_map and the last largest person structure to track the largest in O(n).)

*standard format:
Example:
    int search(vector<int>& nums, int target) {
                
        int left = 0;
        int right = nums.size() - 1;
        
        while (left <= right)
        {
            auto middle = left + (right - left) / 2;
            if (nums[middle] < target) left = middle + 1;
            else if (nums[middle] == target) return middle;
            else right = middle - 1; //right = middle works even better
        }
        
        return -1;
    }

*if a binary search cannot be stopped, the recipe is listed below:
Example:
        int K_min = 1;
        int K_max = *max_element(piles.begin(), piles.end());
        int K_middle;
        int K_prev = -1;
        
        while (K_min <= K_max)
        {
            K_middle = K_min + (K_max - K_min) / 2;
            
            if (K_middle == K_prev) break;
            
            auto H_middle = get_hour(piles, K_middle);
            
            if (H_middle > H) K_min = K_middle + 1;
            else if (H_middle < H) K_max = K_middle;
            else break;
        
            K_prev = K_middle;
        }
