https://en.wikipedia.org/wiki/Binary_search_algorithm

function binary_search(A, n, T) is
    L := 0
    R := n − 1
    while L ≤ R do
        m := floor((L + R) / 2)
        if A[m] < T then
            L := m + 1
        else if A[m] > T then
            R := m − 1
        else:
            return m
    return unsuccessful
    
function binary_search_leftmost(A, n, T):
    L := 0
    R := n
    while L < R:
        m := floor((L + R) / 2)
        if A[m] < T:
            L := m + 1
        else:
            R := m
    return L
    
function binary_search_rightmost(A, n, T):
    L := 0
    R := n
    while L < R:
        m := floor((L + R) / 2)
        if A[m] > T:
            R := m
        else:
            L := m + 1
    return R - 1

continuous: 

while (l + 1.0E-6 < r)
{
    ... l = mid
    ... r = mid
}

1533. Find the Index of the Large Integer (note the left and right updates, re-do!)
1060. Missing Element in Sorted Array (re-do this by using binary search)
1064. Fixed Point (binary search, note only 1 element special case. re-do!)
875. Koko Eating Bananas (re-do!!! Do not make mistakes. The binary search may not stop for ever)
911. Online Election (I did not figure out the solution. Have to re-do!!! Notice the unordered_map and the last largest person structure to track the largest in O(n).)
1552. Magnetic Force Between Two Balls (classic! classic! classic! definitely re-do!
    similar quesitons:
        410. Split Array Largest Sum
        774. Minimize Max Distance to Gas Station
        875. Koko Eating Bananas
        1011. Capacity To Ship Packages Within D Days
        1231. Divide Chocolate
        1482. Minimum Number of Days to Make m Bouquets)
410. Split Array Largest Sum (a very important question! binary search. need to convert the problem. can re-do!)
774. Minimize Max Distance to Gas Station (Classic!!! given the minimal maximum distance, how many new gas stations needed. The larger the minimal maximum distance, the smaller number of new gas stations needed. Use binary search to find the left most minimal maximum distance. note that for continuous values, this is the way of stop, i.e. while (l + 1.0E-6 < r). a very very important question. re-do!)
1482. Minimum Number of Days to Make m Bouquets (at day 0, we cannot make any bouquets. at the maximum day, all flowers blossom, and we can see whether we can make m bouquets each of k flowers. binary search to solve the problem and find the left most solution.)

*standard format:
Example:
    int search(vector<int>& nums, int target) {
                
        int left = 0;
        int right = nums.size() - 1;
        
        while (left <= right)
        {
            auto middle = left + (right - left) / 2;
            if (nums[middle] < target) left = middle + 1;
            else if (nums[middle] == target) return middle;
            else right = middle - 1; //right = middle works even better (but might got convergence issues......)
        }
        
        return -1;
    }

*if a binary search cannot be stopped, the recipe is listed below:
Example:
        int K_min = 1;
        int K_max = *max_element(piles.begin(), piles.end());
        int K_middle;
        int K_prev = -1;
        
        while (K_min <= K_max)
        {
            K_middle = K_min + (K_max - K_min) / 2;
            
            if (K_middle == K_prev) break;
            
            auto H_middle = get_hour(piles, K_middle);
            
            if (H_middle > H) K_min = K_middle + 1;
            else if (H_middle < H) K_max = K_middle;
            else break;
        
            K_prev = K_middle;
        }
