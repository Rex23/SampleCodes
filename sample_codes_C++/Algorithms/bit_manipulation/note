*Problems:
1238. Circular Permutation in Binary Representation (grey code)
405. Convert a Number to Hexadecimal (very classic, but be re-done several times!)

*In C++ octal numbers are denoted by beginning always with a 0 digit.
http://www.cplusplus.com/doc/hex/

*In C++, hexadecimal numbers are preceded by 0x (zero, x).
http://www.cplusplus.com/doc/hex/

*1 << 0 (2^0) 
 1 << 1 (2^1) 
 1 << 2 (2^2) ...

*divide a number by 2: num=num>>1

*0 ^ a_number = a_number

*reminder of a number by 2: num = num & 1

*the last bit of a binary: num = num & 1

*'+' preceeds '&': 
Example: 
1 + 2 & 3

*for any number, couting number of bits of 1:
Equation:
f(N) = f(N / 2) + N % 2

Example:
338. Counting Bits
Solution: (Java)
public int[] countBits(int num) {
    int[] f = new int[num + 1];
    for (int i=1; i<=num; i++) f[i] = f[i >> 1] + (i & 1);
    return f;
}

*grey code:
https://cp-algorithms.com/algebra/gray-code.html
Example:
A sequence of grey code:
#include <iostream>
#include <bitset>
using namespace std;

int main()
{
   int n = 5;
   for (int i = 0; i < (1 << n); ++i)
   {
       std::cout << std::bitset<16>((i ^ (i >> 1))) << std::endl; //note the use of parentesis
   }
   
   return 0;
}

*operator >> (<<) precedes ^

*output bit in C++
https://katyscode.wordpress.com/2012/05/12/printing-numbers-in-binary-format-in-c/#:~:text=int%20v%20%3D%200x12345678%3B%20for%20(,%3E%3E%20i)%20%26%201)%3B
Example1:
int v = 0x12345678;
for (int i = 31; i >= 0; i--)
    std::cout << ((v >> i) & 1); //the & eliminates all the higher order bits

Example2:
#include <bitset>
int v = 0x12345678;
std::cout << std::bitset<32>(v);

*__builtin_popcount(int) function is used to count the number of oneâ€™s(set bits) in an integer.

*std::bitset<32>(i).count() //count number of 1's

*convert a decimal number to a hexadecimal number (including negative number)
Example:
note that: 
1. if num is changed to unsigned, the count condition can be omitted.
2. num % 16 and num & 0xf are different for negative numbers
3. num & 0xf and num & 15 are the same
4. num >> 4 and num / 16 are different for negative numbers

    string toHex(int num) {
        
        if (num == 0) return "0";
        
        std::vector <string> hex{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};
        
        string result;
        int count = 0;
        while (num != 0 && count < 8)
        {
            result = hex[num & 0xf] + result;
            
            num = num >> 4;
            
            count++;
        }
        
        return result;
    }

