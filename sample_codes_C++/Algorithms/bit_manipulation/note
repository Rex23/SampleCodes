*Problems:
1442. Count Triplets That Can Form Two Arrays of Equal XOR (definitely re-do, needs some derivations on XOR operations)
1238. Circular Permutation in Binary Representation (grey code)
405. Convert a Number to Hexadecimal (very classic, but be re-done several times!)
342. Power of Four (note the without loop solution)
1310. XOR Queries of a Subarray (pre_sum solution, X[L] ^ X[L + 1] ^ ... X[R] = pre_sum[L - 1] ^ pre_sum[R] for L > 0 || pre_sum[R] for L == 0)
260. Single Number III (did not solve it... re-do and understand the solution.)
137. Single Number II (very important! See the derivations! https://lenchen.medium.com/leetcode-137-single-number-ii-31af98b0f462)

*In C++ octal numbers are denoted by beginning always with a 0 digit.
http://www.cplusplus.com/doc/hex/

*In C++, hexadecimal numbers are preceded by 0x (zero, x).
http://www.cplusplus.com/doc/hex/

*1 << 0 (2^0) 
 1 << 1 (2^1) 
 1 << 2 (2^2) ...

*divide a number by 2: num=num>>1

*check whether the reminder is 1 and divide a number by 2:
Example:
 for i in range(11):
     print("Test bit operation: ", 1 & i, i, i >> 1)

*0 ^ a_number = a_number

*reminder of a number by 2: num = num & 1

*the last bit of a binary: num = num & 1

*'+' preceeds '&': 
Example: 
1 + 2 & 3

*for any number, couting number of bits of 1:
Equation:
f(N) = f(N / 2) + N % 2

Example:
338. Counting Bits
Solution: (Java)
public int[] countBits(int num) {
    int[] f = new int[num + 1];
    for (int i=1; i<=num; i++) f[i] = f[i >> 1] + (i & 1);
    return f;
}

*grey code:
https://cp-algorithms.com/algebra/gray-code.html
Example:
A sequence of grey code:
#include <iostream>
#include <bitset>
using namespace std;

int main()
{
   int n = 5;
   for (int i = 0; i < (1 << n); ++i)
   {
       std::cout << std::bitset<16>((i ^ (i >> 1))) << std::endl; //note the use of parentesis
   }
   
   return 0;
}

*operator >> (<<) precedes ^

*output bit in C++
https://katyscode.wordpress.com/2012/05/12/printing-numbers-in-binary-format-in-c/#:~:text=int%20v%20%3D%200x12345678%3B%20for%20(,%3E%3E%20i)%20%26%201)%3B
Example1:
int v = 0x12345678;
for (int i = 31; i >= 0; i--)
    std::cout << ((v >> i) & 1); //the & eliminates all the higher order bits

Example2:
#include <bitset>
int v = 0x12345678;
std::cout << std::bitset<32>(v);

*__builtin_popcount(int) function is used to count the number of oneâ€™s(set bits) in an integer.

*std::bitset<32>(i).count() //count number of 1's

*convert a decimal number to a hexadecimal number (including negative number)
Example:
note that: 
1. if num is changed to unsigned, the count condition can be omitted.
2. num % 16 and num & 0xf are different for negative numbers
3. num & 0xf and num & 15 are the same
4. num >> 4 and num / 16 are different for negative numbers

    string toHex(int num) {
        
        if (num == 0) return "0";
        
        std::vector <string> hex{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};
        
        string result;
        int count = 0;
        while (num != 0 && count < 8)
        {
            result = hex[num & 0xf] + result;
            
            num = num >> 4;
            
            count++;
        }
        
        return result;
    }
    
 *shift exponent 32 is too large for 1 << 32.
 solution: (long) 1 << 32
 
 *check whether a number is a power of 4:
 Java:
 public boolean isPowerOfFour(int num) {
    return num > 0 && (num&(num-1)) == 0 && (num & 0x55555555) != 0;
    //0x55555555 is to get rid of those power of 2 but not power of 4
    //so that the single 1 bit always appears at the odd position 
}
    
 Good solution without good explanation,it's easy to find that power of 4 numbers have those 3 common features.
 First,greater than 0.Second,only have one '1' bit in their binary notation,so we use x&(x-1) to delete the lowest '1',
 and if then it becomes 0,it prove that there is only one '1' bit.
 Third,the only '1' bit should be locate at the odd location,for example,16.It's binary is 00010000.
 So we can use '0x55555555' to check if the '1' bit is in the right place.With this thought we can code it out easily!
 
 *X[L] ^ X[L + 1] ^ ... ^ X[R]:
 pre_sum solution, X[L] ^ X[L + 1] ^ ... X[R] = pre_sum[L - 1] ^ pre_sum[R] for L > 0 || pre_sum[R] for L == 0)
 
*a ^ b will keep the difference.

*a & (-a) will keep the right most bit

*(a ^ b) ^ a = b or (a ^ b) ^ b = a

*hexadecimal number example:
https://stackoverflow.com/questions/10493411/what-is-bit-masking
uint8_t mask = 0x0f;   // 00001111b
uint8_t value = 0x55;  // 01010101b

